{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport { useRef, useEffect } from 'react';\nimport { useInstantLayoutTransition } from '../projection/use-instant-layout-transition.mjs';\nimport { useForceUpdate } from './use-force-update.mjs';\nimport { instantAnimationState } from './use-instant-transition-state.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nfunction useInstantTransition() {\n  const _useForceUpdate = useForceUpdate(),\n    _useForceUpdate2 = _slicedToArray(_useForceUpdate, 2),\n    forceUpdate = _useForceUpdate2[0],\n    forcedRenderCount = _useForceUpdate2[1];\n  const startInstantLayoutTransition = useInstantLayoutTransition();\n  const unlockOnFrameRef = useRef();\n  useEffect(() => {\n    /**\n     * Unblock after two animation frames, otherwise this will unblock too soon.\n     */\n    frame.postRender(() => frame.postRender(() => {\n      /**\n       * If the callback has been called again after the effect\n       * triggered this 2 frame delay, don't unblock animations. This\n       * prevents the previous effect from unblocking the current\n       * instant transition too soon. This becomes more likely when\n       * used in conjunction with React.startTransition().\n       */\n      if (forcedRenderCount !== unlockOnFrameRef.current) return;\n      instantAnimationState.current = false;\n    }));\n  }, [forcedRenderCount]);\n  return callback => {\n    startInstantLayoutTransition(() => {\n      instantAnimationState.current = true;\n      forceUpdate();\n      callback();\n      unlockOnFrameRef.current = forcedRenderCount + 1;\n    });\n  };\n}\nfunction disableInstantTransitions() {\n  instantAnimationState.current = false;\n}\nexport { disableInstantTransitions, useInstantTransition };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}