{"ast":null,"code":"import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\nfunction inertia(_ref) {\n  let keyframes = _ref.keyframes,\n    _ref$velocity = _ref.velocity,\n    velocity = _ref$velocity === void 0 ? 0.0 : _ref$velocity,\n    _ref$power = _ref.power,\n    power = _ref$power === void 0 ? 0.8 : _ref$power,\n    _ref$timeConstant = _ref.timeConstant,\n    timeConstant = _ref$timeConstant === void 0 ? 325 : _ref$timeConstant,\n    _ref$bounceDamping = _ref.bounceDamping,\n    bounceDamping = _ref$bounceDamping === void 0 ? 10 : _ref$bounceDamping,\n    _ref$bounceStiffness = _ref.bounceStiffness,\n    bounceStiffness = _ref$bounceStiffness === void 0 ? 500 : _ref$bounceStiffness,\n    modifyTarget = _ref.modifyTarget,\n    min = _ref.min,\n    max = _ref.max,\n    _ref$restDelta = _ref.restDelta,\n    restDelta = _ref$restDelta === void 0 ? 0.5 : _ref$restDelta,\n    restSpeed = _ref.restSpeed;\n  const origin = keyframes[0];\n  const state = {\n    done: false,\n    value: origin\n  };\n  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;\n  const nearestBoundary = v => {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n  if (target !== ideal) amplitude = target - origin;\n  const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);\n  const calcLatest = t => target + calcDelta(t);\n  const applyFriction = t => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n  let timeReachedBoundary;\n  let spring$1;\n  const checkCatchBoundary = t => {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      // TODO: This should be passing * 1000\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta,\n      restSpeed\n    });\n  };\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: t => {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      let hasUpdatedFrame = false;\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n      if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\nexport { inertia };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}