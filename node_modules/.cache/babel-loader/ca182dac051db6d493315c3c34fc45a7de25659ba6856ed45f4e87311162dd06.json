{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nconst _require = require(\"@apollo/client/core\"),\n  ApolloLink = _require.ApolloLink,\n  Observable = _require.Observable;\nconst _require2 = require(\"@apollo/client/link/http\"),\n  createSignalIfSupported = _require2.createSignalIfSupported,\n  fallbackHttpConfig = _require2.fallbackHttpConfig,\n  parseAndCheckHttpResponse = _require2.parseAndCheckHttpResponse,\n  rewriteURIForGET = _require2.rewriteURIForGET,\n  selectHttpOptionsAndBody = _require2.selectHttpOptionsAndBody,\n  selectURI = _require2.selectURI,\n  serializeFetchParameter = _require2.serializeFetchParameter;\nconst extractFiles = require(\"extract-files/public/extractFiles.js\");\nconst formDataAppendFile = require(\"./formDataAppendFile.js\");\nconst isExtractableFile = require(\"./isExtractableFile.js\");\n\n/**\n * Creates a\n * [terminating Apollo Link](https://apollographql.com/docs/react/api/link/introduction/#the-terminating-link)\n * for [Apollo Client](https://apollographql.com/docs/react) that fetches a\n * [GraphQL multipart request](https://github.com/jaydenseric/graphql-multipart-request-spec)\n * if the GraphQL variables contain files (by default\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/FileList),\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File),\n * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob), or\n * [`ReactNativeFile`](#class-reactnativefile) instances), or else fetches a\n * regular\n * [GraphQL POST or GET request](https://apollographql.com/docs/apollo-server/requests)\n * (depending on the config and GraphQL operation).\n *\n * Some of the options are similar to the\n * [`createHttpLink` options](https://apollographql.com/docs/react/api/link/apollo-link-http/#httplink-constructor-options).\n * @see [GraphQL multipart request spec](https://github.com/jaydenseric/graphql-multipart-request-spec).\n * @kind function\n * @name createUploadLink\n * @param {object} options Options.\n * @param {string} [options.uri=\"/graphql\"] GraphQL endpoint URI.\n * @param {boolean} [options.useGETForQueries] Should GET be used to fetch queries, if there are no files to upload.\n * @param {ExtractableFileMatcher} [options.isExtractableFile=isExtractableFile] Customizes how files are matched in the GraphQL operation for extraction.\n * @param {class} [options.FormData] [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) implementation to use, defaulting to the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) global.\n * @param {FormDataFileAppender} [options.formDataAppendFile=formDataAppendFile] Customizes how extracted files are appended to the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) instance.\n * @param {Function} [options.fetch] [`fetch`](https://fetch.spec.whatwg.org) implementation to use, defaulting to the [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) global.\n * @param {FetchOptions} [options.fetchOptions] [`fetch` options]{@link FetchOptions}; overridden by upload requirements.\n * @param {string} [options.credentials] Overrides `options.fetchOptions.credentials`.\n * @param {object} [options.headers] Merges with and overrides `options.fetchOptions.headers`.\n * @param {boolean} [options.includeExtensions=false] Toggles sending `extensions` fields to the GraphQL server.\n * @returns {ApolloLink} A [terminating Apollo Link](https://apollographql.com/docs/react/api/link/introduction/#the-terminating-link).\n * @example <caption>Ways to `import`.</caption>\n * ```js\n * import { createUploadLink } from \"apollo-upload-client\";\n * ```\n *\n * ```js\n * import createUploadLink from \"apollo-upload-client/public/createUploadLink.js\";\n * ```\n * @example <caption>Ways to `require`.</caption>\n * ```js\n * const { createUploadLink } = require(\"apollo-upload-client\");\n * ```\n *\n * ```js\n * const createUploadLink = require(\"apollo-upload-client/public/createUploadLink.js\");\n * ```\n * @example <caption>A basic Apollo Client setup.</caption>\n * ```js\n * import { ApolloClient, InMemoryCache } from \"@apollo/client\";\n * import createUploadLink from \"apollo-upload-client/public/createUploadLink.js\";\n *\n * const client = new ApolloClient({\n *   cache: new InMemoryCache(),\n *   link: createUploadLink(),\n * });\n * ```\n */\nmodule.exports = function createUploadLink({\n  uri: fetchUri = \"/graphql\",\n  useGETForQueries,\n  isExtractableFile: customIsExtractableFile = isExtractableFile,\n  FormData: CustomFormData,\n  formDataAppendFile: customFormDataAppendFile = formDataAppendFile,\n  fetch: customFetch,\n  fetchOptions,\n  credentials,\n  headers,\n  includeExtensions\n} = {}) {\n  const linkConfig = {\n    http: {\n      includeExtensions\n    },\n    options: fetchOptions,\n    credentials,\n    headers\n  };\n  return new ApolloLink(operation => {\n    const context = operation.getContext();\n    const _context$clientAwaren = context.clientAwareness,\n      _context$clientAwaren2 = _context$clientAwaren === void 0 ? {} : _context$clientAwaren,\n      name = _context$clientAwaren2.name,\n      version = _context$clientAwaren2.version,\n      headers = context.headers;\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: _objectSpread(_objectSpread(_objectSpread({}, name && {\n        \"apollographql-client-name\": name\n      }), version && {\n        \"apollographql-client-version\": version\n      }), headers)\n    };\n    const _selectHttpOptionsAnd = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig),\n      options = _selectHttpOptionsAnd.options,\n      body = _selectHttpOptionsAnd.body;\n    const _extractFiles = extractFiles(body, \"\", customIsExtractableFile),\n      clone = _extractFiles.clone,\n      files = _extractFiles.files;\n    let uri = selectURI(operation, fetchUri);\n    if (files.size) {\n      // Automatically set by `fetch` when the `body` is a `FormData` instance.\n      delete options.headers[\"content-type\"];\n\n      // GraphQL multipart request spec:\n      // https://github.com/jaydenseric/graphql-multipart-request-spec\n\n      const RuntimeFormData = CustomFormData || FormData;\n      const form = new RuntimeFormData();\n      form.append(\"operations\", serializeFetchParameter(clone, \"Payload\"));\n      const map = {};\n      let i = 0;\n      files.forEach(paths => {\n        map[++i] = paths;\n      });\n      form.append(\"map\", JSON.stringify(map));\n      i = 0;\n      files.forEach((paths, file) => {\n        customFormDataAppendFile(form, ++i, file);\n      });\n      options.body = form;\n    } else {\n      if (useGETForQueries &&\n      // If the operation contains some mutations GET shouldn’t be used.\n      !operation.query.definitions.some(definition => definition.kind === \"OperationDefinition\" && definition.operation === \"mutation\")) options.method = \"GET\";\n      if (options.method === \"GET\") {\n        const _rewriteURIForGET = rewriteURIForGET(uri, body),\n          newURI = _rewriteURIForGET.newURI,\n          parseError = _rewriteURIForGET.parseError;\n        if (parseError)\n          // Apollo’s `HttpLink` uses `fromError` for this, but it’s not\n          // exported from `@apollo/client/link/http`.\n          return new Observable(observer => {\n            observer.error(parseError);\n          });\n        uri = newURI;\n      } else options.body = serializeFetchParameter(clone, \"Payload\");\n    }\n    const _createSignalIfSuppor = createSignalIfSupported(),\n      controller = _createSignalIfSuppor.controller;\n    if (controller) {\n      if (options.signal)\n        // Respect the user configured abort controller signal.\n        options.signal.aborted ?\n        // Signal already aborted, so immediately abort.\n        controller.abort() :\n        // Signal not already aborted, so setup a listener to abort when it\n        // does.\n        options.signal.addEventListener(\"abort\", () => {\n          controller.abort();\n        }, {\n          // Prevent a memory leak if the user configured abort controller\n          // is long lasting, or controls multiple things.\n          once: true\n        });\n      options.signal = controller.signal;\n    }\n    const runtimeFetch = customFetch || fetch;\n    return new Observable(observer => {\n      // Used to track if the observable is being cleaned up.\n      let cleaningUp;\n      runtimeFetch(uri, options).then(response => {\n        // Forward the response on the context.\n        operation.setContext({\n          response\n        });\n        return response;\n      }).then(parseAndCheckHttpResponse(operation)).then(result => {\n        observer.next(result);\n        observer.complete();\n      }).catch(error => {\n        // If the observable is being cleaned up, there is no need to call\n        // next or error because there are no more subscribers. An error after\n        // cleanup begins is likely from the cleanup function aborting the\n        // fetch.\n        if (!cleaningUp) {\n          // For errors such as an invalid fetch URI there will be no GraphQL\n          // result with errors or data to forward.\n          if (error.result && error.result.errors && error.result.data) observer.next(error.result);\n          observer.error(error);\n        }\n      });\n\n      // Cleanup function.\n      return () => {\n        cleaningUp = true;\n\n        // Abort fetch. It’s ok to signal an abort even when not fetching.\n        if (controller) controller.abort();\n      };\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}