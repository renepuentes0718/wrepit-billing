{"ast":null,"code":"const _excluded = [\"attrX\", \"attrY\", \"attrScale\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"],\n  _excluded2 = [\"transitionEnd\", \"transition\"],\n  _excluded3 = [\"root\"],\n  _excluded4 = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"],\n  _excluded5 = [\"keyframes\", \"restDelta\", \"restSpeed\"],\n  _excluded6 = [\"KeyframeResolver\"],\n  _excluded7 = [\"onComplete\", \"onUpdate\", \"motionValue\"],\n  _excluded8 = [\"motionValue\", \"onUpdate\", \"onComplete\"],\n  _excluded9 = [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\", \"elapsed\"],\n  _excluded10 = [\"transitionEnd\", \"transition\"],\n  _excluded11 = [\"transition\", \"transitionEnd\"],\n  _excluded12 = [\"transition\", \"transitionEnd\"],\n  _excluded13 = [\"willChange\"],\n  _excluded14 = [\"children\"],\n  _excluded15 = [\"defaultTransition\"],\n  _excluded16 = [\"delay\", \"times\", \"type\"],\n  _excluded17 = [\"container\"],\n  _excluded18 = [\"children\", \"as\", \"axis\", \"onReorder\", \"values\"],\n  _excluded19 = [\"children\", \"style\", \"value\", \"as\", \"onDrag\", \"layout\"],\n  _excluded20 = [\"container\", \"target\", \"layoutEffect\"],\n  _excluded21 = [\"renderer\"],\n  _excluded22 = [\"renderer\"],\n  _excluded23 = [\"children\", \"isValidProp\"];\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).Motion = {}, t.React);\n}(this, function (t, e) {\n  \"use strict\";\n\n  function n(t) {\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (n) {\n      if (\"default\" !== n) {\n        var s = Object.getOwnPropertyDescriptor(t, n);\n        Object.defineProperty(e, n, s.get ? s : {\n          enumerable: !0,\n          get: function () {\n            return t[n];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n  var s = n(e),\n    i = React,\n    o = Symbol.for(\"react.element\"),\n    r = Symbol.for(\"react.fragment\"),\n    a = Object.prototype.hasOwnProperty,\n    l = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,\n    u = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    };\n  function c(t, e, n) {\n    var s,\n      i = {},\n      r = null,\n      c = null;\n    for (s in void 0 !== n && (r = \"\" + n), void 0 !== e.key && (r = \"\" + e.key), void 0 !== e.ref && (c = e.ref), e) a.call(e, s) && !u.hasOwnProperty(s) && (i[s] = e[s]);\n    if (t && t.defaultProps) for (s in e = t.defaultProps) void 0 === i[s] && (i[s] = e[s]);\n    return {\n      $$typeof: o,\n      type: t,\n      key: r,\n      ref: c,\n      props: i,\n      _owner: l.current\n    };\n  }\n  const h = r,\n    d = c,\n    m = c,\n    p = e.createContext({\n      transformPagePoint: t => t,\n      isStatic: !1,\n      reducedMotion: \"never\"\n    }),\n    f = e.createContext({}),\n    g = e.createContext(null),\n    y = \"undefined\" != typeof document,\n    v = y ? e.useLayoutEffect : e.useEffect,\n    x = e.createContext({\n      strict: !1\n    }),\n    P = t => t.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase(),\n    w = \"data-\" + P(\"framerAppearId\"),\n    T = {\n      skipAnimations: !1,\n      useManualTiming: !1\n    };\n  class S {\n    constructor() {\n      this.order = [], this.scheduled = new Set();\n    }\n    add(t) {\n      if (!this.scheduled.has(t)) return this.scheduled.add(t), this.order.push(t), !0;\n    }\n    remove(t) {\n      const e = this.order.indexOf(t);\n      -1 !== e && (this.order.splice(e, 1), this.scheduled.delete(t));\n    }\n    clear() {\n      this.order.length = 0, this.scheduled.clear();\n    }\n  }\n  const b = [\"read\", \"resolveKeyframes\", \"update\", \"preRender\", \"render\", \"postRender\"];\n  function A(t, e) {\n    let n = !1,\n      s = !0;\n    const i = {\n        delta: 0,\n        timestamp: 0,\n        isProcessing: !1\n      },\n      o = b.reduce((t, e) => (t[e] = function (t) {\n        let e = new S(),\n          n = new S(),\n          s = 0,\n          i = !1,\n          o = !1;\n        const r = new WeakSet(),\n          a = {\n            schedule: function (t) {\n              let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n              let a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n              const l = a && i,\n                u = l ? e : n;\n              return o && r.add(t), u.add(t) && l && i && (s = e.order.length), t;\n            },\n            cancel: t => {\n              n.remove(t), r.delete(t);\n            },\n            process: l => {\n              if (i) o = !0;else {\n                var _ref;\n                if (i = !0, (_ref = [n, e], e = _ref[0], n = _ref[1]), n.clear(), s = e.order.length, s) for (let n = 0; n < s; n++) {\n                  const s = e.order[n];\n                  r.has(s) && (a.schedule(s), t()), s(l);\n                }\n                i = !1, o && (o = !1, a.process(l));\n              }\n            }\n          };\n        return a;\n      }(() => n = !0), t), {}),\n      r = t => {\n        o[t].process(i);\n      },\n      a = () => {\n        const o = T.useManualTiming ? i.timestamp : performance.now();\n        n = !1, i.delta = s ? 1e3 / 60 : Math.max(Math.min(o - i.timestamp, 40), 1), i.timestamp = o, i.isProcessing = !0, b.forEach(r), i.isProcessing = !1, n && e && (s = !1, t(a));\n      };\n    return {\n      schedule: b.reduce((e, r) => {\n        const l = o[r];\n        return e[r] = function (e) {\n          let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          return n || (n = !0, s = !0, i.isProcessing || t(a)), l.schedule(e, o, r);\n        }, e;\n      }, {}),\n      cancel: t => b.forEach(e => o[e].cancel(t)),\n      state: i,\n      steps: o\n    };\n  }\n  const _A = A(queueMicrotask, !1),\n    E = _A.schedule,\n    C = _A.cancel;\n  function V(t) {\n    return t && \"object\" == typeof t && Object.prototype.hasOwnProperty.call(t, \"current\");\n  }\n  function M(t, n, s) {\n    return e.useCallback(e => {\n      e && t.mount && t.mount(e), n && (e ? n.mount(e) : n.unmount()), s && (\"function\" == typeof s ? s(e) : V(s) && (s.current = e));\n    }, [n]);\n  }\n  function R(t) {\n    return \"string\" == typeof t || Array.isArray(t);\n  }\n  function D(t) {\n    return null !== t && \"object\" == typeof t && \"function\" == typeof t.start;\n  }\n  const k = [\"animate\", \"whileInView\", \"whileFocus\", \"whileHover\", \"whileTap\", \"whileDrag\", \"exit\"],\n    L = [\"initial\", ...k];\n  function B(t) {\n    return D(t.animate) || L.some(e => R(t[e]));\n  }\n  function F(t) {\n    return Boolean(B(t) || t.variants);\n  }\n  function j(t) {\n    const _ref2 = function (t, e) {\n        if (B(t)) {\n          const e = t.initial,\n            n = t.animate;\n          return {\n            initial: !1 === e || R(e) ? e : void 0,\n            animate: R(n) ? n : void 0\n          };\n        }\n        return !1 !== t.inherit ? e : {};\n      }(t, e.useContext(f)),\n      n = _ref2.initial,\n      s = _ref2.animate;\n    return e.useMemo(() => ({\n      initial: n,\n      animate: s\n    }), [O(n), O(s)]);\n  }\n  function O(t) {\n    return Array.isArray(t) ? t.join(\" \") : t;\n  }\n  const I = {\n      animation: [\"animate\", \"variants\", \"whileHover\", \"whileTap\", \"exit\", \"whileInView\", \"whileFocus\", \"whileDrag\"],\n      exit: [\"exit\"],\n      drag: [\"drag\", \"dragControls\"],\n      focus: [\"whileFocus\"],\n      hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n      tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n      pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n      inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n      layout: [\"layout\", \"layoutId\"]\n    },\n    U = {};\n  for (const t in I) U[t] = {\n    isEnabled: e => I[t].some(t => !!e[t])\n  };\n  function W(t) {\n    for (const e in t) U[e] = _objectSpread(_objectSpread({}, U[e]), t[e]);\n  }\n  const N = e.createContext({}),\n    z = e.createContext({}),\n    H = Symbol.for(\"motionComponentSymbol\");\n  function $(_ref3) {\n    let t = _ref3.preloadedFeatures,\n      n = _ref3.createVisualElement,\n      s = _ref3.useRender,\n      i = _ref3.useVisualState,\n      o = _ref3.Component;\n    t && W(t);\n    const r = e.forwardRef(function (r, a) {\n      let l;\n      const u = _objectSpread(_objectSpread(_objectSpread({}, e.useContext(p)), r), {}, {\n          layoutId: Y(r)\n        }),\n        c = u.isStatic,\n        h = j(r),\n        P = i(r, c);\n      if (!c && y) {\n        h.visualElement = function (t, n, s, i) {\n          const _e$useContext = e.useContext(f),\n            o = _e$useContext.visualElement,\n            r = e.useContext(x),\n            a = e.useContext(g),\n            l = e.useContext(p).reducedMotion,\n            u = e.useRef();\n          i = i || r.renderer, !u.current && i && (u.current = i(t, {\n            visualState: n,\n            parent: o,\n            props: s,\n            presenceContext: a,\n            blockInitialAnimation: !!a && !1 === a.initial,\n            reducedMotionConfig: l\n          }));\n          const c = u.current;\n          e.useInsertionEffect(() => {\n            c && c.update(s, a);\n          });\n          const h = e.useRef(Boolean(s[w] && !window.HandoffComplete));\n          return v(() => {\n            c && (E.postRender(c.render), h.current && c.animationState && c.animationState.animateChanges());\n          }), e.useEffect(() => {\n            c && (c.updateFeatures(), !h.current && c.animationState && c.animationState.animateChanges(), h.current && (h.current = !1, window.HandoffComplete = !0));\n          }), c;\n        }(o, P, u, n);\n        const s = e.useContext(z),\n          i = e.useContext(x).strict;\n        h.visualElement && (l = h.visualElement.loadFeatures(u, i, t, s));\n      }\n      return m(f.Provider, {\n        value: h,\n        children: [l && h.visualElement ? d(l, _objectSpread({\n          visualElement: h.visualElement\n        }, u)) : null, s(o, r, M(P, h.visualElement, a), P, c, h.visualElement)]\n      });\n    });\n    return r[H] = o, r;\n  }\n  function Y(_ref4) {\n    let t = _ref4.layoutId;\n    const n = e.useContext(N).id;\n    return n && void 0 !== t ? n + \"-\" + t : t;\n  }\n  function X(t) {\n    function e(e) {\n      let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return $(t(e, n));\n    }\n    if (\"undefined\" == typeof Proxy) return e;\n    const n = new Map();\n    return new Proxy(e, {\n      get: (t, s) => (n.has(s) || n.set(s, e(s)), n.get(s))\n    });\n  }\n  const K = [\"animate\", \"circle\", \"defs\", \"desc\", \"ellipse\", \"g\", \"image\", \"line\", \"filter\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"rect\", \"stop\", \"switch\", \"symbol\", \"svg\", \"text\", \"tspan\", \"use\", \"view\"];\n  function G(t) {\n    return \"string\" == typeof t && !t.includes(\"-\") && !!(K.indexOf(t) > -1 || /[A-Z]/u.test(t));\n  }\n  const _ = {};\n  function q(t) {\n    Object.assign(_, t);\n  }\n  const Z = [\"transformPerspective\", \"x\", \"y\", \"z\", \"translateX\", \"translateY\", \"translateZ\", \"scale\", \"scaleX\", \"scaleY\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\"],\n    J = new Set(Z);\n  function Q(t, _ref5) {\n    let e = _ref5.layout,\n      n = _ref5.layoutId;\n    return J.has(t) || t.startsWith(\"origin\") || (e || void 0 !== n) && (!!_[t] || \"opacity\" === t);\n  }\n  const tt = t => Boolean(t && t.getVelocity),\n    et = {\n      x: \"translateX\",\n      y: \"translateY\",\n      z: \"translateZ\",\n      transformPerspective: \"perspective\"\n    },\n    nt = Z.length;\n  function st(t, _ref6, s, i) {\n    let _ref6$enableHardwareA = _ref6.enableHardwareAcceleration,\n      e = _ref6$enableHardwareA === void 0 ? !0 : _ref6$enableHardwareA,\n      _ref6$allowTransformN = _ref6.allowTransformNone,\n      n = _ref6$allowTransformN === void 0 ? !0 : _ref6$allowTransformN;\n    let o = \"\";\n    for (let e = 0; e < nt; e++) {\n      const n = Z[e];\n      if (void 0 !== t[n]) {\n        o += `${et[n] || n}(${t[n]}) `;\n      }\n    }\n    return e && !t.z && (o += \"translateZ(0)\"), o = o.trim(), i ? o = i(t, s ? \"\" : o) : n && s && (o = \"none\"), o;\n  }\n  const it = t => e => \"string\" == typeof e && e.startsWith(t),\n    ot = it(\"--\"),\n    rt = it(\"var(--\"),\n    at = t => !!rt(t) && lt.test(t.split(\"/*\")[0].trim()),\n    lt = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu,\n    ut = (t, e) => e && \"number\" == typeof t ? e.transform(t) : t,\n    ct = (t, e, n) => n > e ? e : n < t ? t : n,\n    ht = {\n      test: t => \"number\" == typeof t,\n      parse: parseFloat,\n      transform: t => t\n    },\n    dt = _objectSpread(_objectSpread({}, ht), {}, {\n      transform: t => ct(0, 1, t)\n    }),\n    mt = _objectSpread(_objectSpread({}, ht), {}, {\n      default: 1\n    }),\n    pt = t => Math.round(1e5 * t) / 1e5,\n    ft = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu,\n    gt = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu,\n    yt = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n  function vt(t) {\n    return \"string\" == typeof t;\n  }\n  const xt = t => ({\n      test: e => vt(e) && e.endsWith(t) && 1 === e.split(\" \").length,\n      parse: parseFloat,\n      transform: e => `${e}${t}`\n    }),\n    Pt = xt(\"deg\"),\n    wt = xt(\"%\"),\n    Tt = xt(\"px\"),\n    St = xt(\"vh\"),\n    bt = xt(\"vw\"),\n    At = _objectSpread(_objectSpread({}, wt), {}, {\n      parse: t => wt.parse(t) / 100,\n      transform: t => wt.transform(100 * t)\n    }),\n    Et = _objectSpread(_objectSpread({}, ht), {}, {\n      transform: Math.round\n    }),\n    Ct = {\n      borderWidth: Tt,\n      borderTopWidth: Tt,\n      borderRightWidth: Tt,\n      borderBottomWidth: Tt,\n      borderLeftWidth: Tt,\n      borderRadius: Tt,\n      radius: Tt,\n      borderTopLeftRadius: Tt,\n      borderTopRightRadius: Tt,\n      borderBottomRightRadius: Tt,\n      borderBottomLeftRadius: Tt,\n      width: Tt,\n      maxWidth: Tt,\n      height: Tt,\n      maxHeight: Tt,\n      size: Tt,\n      top: Tt,\n      right: Tt,\n      bottom: Tt,\n      left: Tt,\n      padding: Tt,\n      paddingTop: Tt,\n      paddingRight: Tt,\n      paddingBottom: Tt,\n      paddingLeft: Tt,\n      margin: Tt,\n      marginTop: Tt,\n      marginRight: Tt,\n      marginBottom: Tt,\n      marginLeft: Tt,\n      rotate: Pt,\n      rotateX: Pt,\n      rotateY: Pt,\n      rotateZ: Pt,\n      scale: mt,\n      scaleX: mt,\n      scaleY: mt,\n      scaleZ: mt,\n      skew: Pt,\n      skewX: Pt,\n      skewY: Pt,\n      distance: Tt,\n      translateX: Tt,\n      translateY: Tt,\n      translateZ: Tt,\n      x: Tt,\n      y: Tt,\n      z: Tt,\n      perspective: Tt,\n      transformPerspective: Tt,\n      opacity: dt,\n      originX: At,\n      originY: At,\n      originZ: Tt,\n      zIndex: Et,\n      backgroundPositionX: Tt,\n      backgroundPositionY: Tt,\n      fillOpacity: dt,\n      strokeOpacity: dt,\n      numOctaves: Et\n    };\n  function Vt(t, e, n, s) {\n    const i = t.style,\n      o = t.vars,\n      r = t.transform,\n      a = t.transformOrigin;\n    let l = !1,\n      u = !1,\n      c = !0;\n    for (const t in e) {\n      const n = e[t];\n      if (ot(t)) {\n        o[t] = n;\n        continue;\n      }\n      const s = Ct[t],\n        h = ut(n, s);\n      if (J.has(t)) {\n        if (l = !0, r[t] = h, !c) continue;\n        n !== (s.default || 0) && (c = !1);\n      } else t.startsWith(\"origin\") ? (u = !0, a[t] = h) : i[t] = h;\n    }\n    if (e.transform || (l || s ? i.transform = st(t.transform, n, c, s) : i.transform && (i.transform = \"none\")), u) {\n      const _a$originX = a.originX,\n        t = _a$originX === void 0 ? \"50%\" : _a$originX,\n        _a$originY = a.originY,\n        e = _a$originY === void 0 ? \"50%\" : _a$originY,\n        _a$originZ = a.originZ,\n        n = _a$originZ === void 0 ? 0 : _a$originZ;\n      i.transformOrigin = `${t} ${e} ${n}`;\n    }\n  }\n  const Mt = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {}\n  });\n  function Rt(t, e, n) {\n    for (const s in e) tt(e[s]) || Q(s, n) || (t[s] = e[s]);\n  }\n  function Dt(t, n, s) {\n    const i = {};\n    return Rt(i, t.style || {}, t), Object.assign(i, function (_ref7, n, s) {\n      let t = _ref7.transformTemplate;\n      return e.useMemo(() => {\n        const e = {\n          style: {},\n          transform: {},\n          transformOrigin: {},\n          vars: {}\n        };\n        return Vt(e, n, {\n          enableHardwareAcceleration: !s\n        }, t), Object.assign({}, e.vars, e.style);\n      }, [n]);\n    }(t, n, s)), i;\n  }\n  function kt(t, e, n) {\n    const s = {},\n      i = Dt(t, e, n);\n    return t.drag && !1 !== t.dragListener && (s.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = \"none\", i.touchAction = !0 === t.drag ? \"none\" : \"pan-\" + (\"x\" === t.drag ? \"y\" : \"x\")), void 0 === t.tabIndex && (t.onTap || t.onTapStart || t.whileTap) && (s.tabIndex = 0), s.style = i, s;\n  }\n  const Lt = new Set([\"animate\", \"exit\", \"variants\", \"initial\", \"style\", \"values\", \"variants\", \"transition\", \"transformTemplate\", \"custom\", \"inherit\", \"onBeforeLayoutMeasure\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"_dragX\", \"_dragY\", \"onHoverStart\", \"onHoverEnd\", \"onViewportEnter\", \"onViewportLeave\", \"globalTapTarget\", \"ignoreStrict\", \"viewport\"]);\n  function Bt(t) {\n    return t.startsWith(\"while\") || t.startsWith(\"drag\") && \"draggable\" !== t || t.startsWith(\"layout\") || t.startsWith(\"onTap\") || t.startsWith(\"onPan\") || t.startsWith(\"onLayout\") || Lt.has(t);\n  }\n  let Ft = t => !Bt(t);\n  function jt(t) {\n    t && (Ft = e => e.startsWith(\"on\") ? !Bt(e) : t(e));\n  }\n  try {\n    jt(require(\"@emotion/is-prop-valid\").default);\n  } catch (t) {}\n  function Ot(t, e, n) {\n    const s = {};\n    for (const i in t) \"values\" === i && \"object\" == typeof t.values || (Ft(i) || !0 === n && Bt(i) || !e && !Bt(i) || t.draggable && i.startsWith(\"onDrag\")) && (s[i] = t[i]);\n    return s;\n  }\n  function It(t, e, n) {\n    return \"string\" == typeof t ? t : Tt.transform(e + n * t);\n  }\n  const Ut = {\n      offset: \"stroke-dashoffset\",\n      array: \"stroke-dasharray\"\n    },\n    Wt = {\n      offset: \"strokeDashoffset\",\n      array: \"strokeDasharray\"\n    };\n  function Nt(t, _ref8, c, h, d) {\n    let e = _ref8.attrX,\n      n = _ref8.attrY,\n      s = _ref8.attrScale,\n      i = _ref8.originX,\n      o = _ref8.originY,\n      r = _ref8.pathLength,\n      _ref8$pathSpacing = _ref8.pathSpacing,\n      a = _ref8$pathSpacing === void 0 ? 1 : _ref8$pathSpacing,\n      _ref8$pathOffset = _ref8.pathOffset,\n      l = _ref8$pathOffset === void 0 ? 0 : _ref8$pathOffset,\n      u = _objectWithoutProperties(_ref8, _excluded);\n    if (Vt(t, u, c, d), h) return void (t.style.viewBox && (t.attrs.viewBox = t.style.viewBox));\n    t.attrs = t.style, t.style = {};\n    const m = t.attrs,\n      p = t.style,\n      f = t.dimensions;\n    m.transform && (f && (p.transform = m.transform), delete m.transform), f && (void 0 !== i || void 0 !== o || p.transform) && (p.transformOrigin = function (t, e, n) {\n      return `${It(e, t.x, t.width)} ${It(n, t.y, t.height)}`;\n    }(f, void 0 !== i ? i : .5, void 0 !== o ? o : .5)), void 0 !== e && (m.x = e), void 0 !== n && (m.y = n), void 0 !== s && (m.scale = s), void 0 !== r && function (t, e) {\n      let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n      t.pathLength = 1;\n      const o = i ? Ut : Wt;\n      t[o.offset] = Tt.transform(-s);\n      const r = Tt.transform(e),\n        a = Tt.transform(n);\n      t[o.array] = `${r} ${a}`;\n    }(m, r, a, l, !1);\n  }\n  const zt = () => ({\n      style: {},\n      transform: {},\n      transformOrigin: {},\n      vars: {},\n      attrs: {}\n    }),\n    Ht = t => \"string\" == typeof t && \"svg\" === t.toLowerCase();\n  function $t(t, n, s, i) {\n    const o = e.useMemo(() => {\n      const e = {\n        style: {},\n        transform: {},\n        transformOrigin: {},\n        vars: {},\n        attrs: {}\n      };\n      return Nt(e, n, {\n        enableHardwareAcceleration: !1\n      }, Ht(i), t.transformTemplate), _objectSpread(_objectSpread({}, e.attrs), {}, {\n        style: _objectSpread({}, e.style)\n      });\n    }, [n]);\n    if (t.style) {\n      const e = {};\n      Rt(e, t.style, t), o.style = _objectSpread(_objectSpread({}, e), o.style);\n    }\n    return o;\n  }\n  function Yt() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    return (n, s, i, _ref9, r) => {\n      let o = _ref9.latestValues;\n      const a = (G(n) ? $t : kt)(s, o, r, n),\n        l = Ot(s, \"string\" == typeof n, t),\n        u = n !== e.Fragment ? _objectSpread(_objectSpread(_objectSpread({}, l), a), {}, {\n          ref: i\n        }) : {},\n        c = s.children,\n        h = e.useMemo(() => tt(c) ? c.get() : c, [c]);\n      return e.createElement(n, _objectSpread(_objectSpread({}, u), {}, {\n        children: h\n      }));\n    };\n  }\n  function Xt(t, _ref10, s, i) {\n    let e = _ref10.style,\n      n = _ref10.vars;\n    Object.assign(t.style, e, i && i.getProjectionStyles(s));\n    for (const e in n) t.style.setProperty(e, n[e]);\n  }\n  const Kt = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\", \"pathLength\", \"startOffset\", \"textLength\", \"lengthAdjust\"]);\n  function Gt(t, e, n, s) {\n    Xt(t, e, void 0, s);\n    for (const n in e.attrs) t.setAttribute(Kt.has(n) ? n : P(n), e.attrs[n]);\n  }\n  function _t(t, e, n) {\n    var s;\n    const i = t.style,\n      o = {};\n    for (const r in i) (tt(i[r]) || e.style && tt(e.style[r]) || Q(r, t) || void 0 !== (null === (s = null == n ? void 0 : n.getValue(r)) || void 0 === s ? void 0 : s.liveStyle)) && (o[r] = i[r]);\n    return o;\n  }\n  function qt(t, e, n) {\n    const s = _t(t, e, n);\n    for (const n in t) if (tt(t[n]) || tt(e[n])) {\n      s[-1 !== Z.indexOf(n) ? \"attr\" + n.charAt(0).toUpperCase() + n.substring(1) : n] = t[n];\n    }\n    return s;\n  }\n  function Zt(t, e, n) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    return \"function\" == typeof e && (e = e(void 0 !== n ? n : t.custom, s, i)), \"string\" == typeof e && (e = t.variants && t.variants[e]), \"function\" == typeof e && (e = e(void 0 !== n ? n : t.custom, s, i)), e;\n  }\n  function Jt(t) {\n    const n = e.useRef(null);\n    return null === n.current && (n.current = t()), n.current;\n  }\n  const Qt = t => Array.isArray(t);\n  function te(t) {\n    const e = tt(t) ? t.get() : t;\n    return n = e, Boolean(n && \"object\" == typeof n && n.mix && n.toValue) ? e.toValue() : e;\n    var n;\n  }\n  const ee = t => (n, s) => {\n    const i = e.useContext(f),\n      o = e.useContext(g),\n      r = () => function (_ref11, s, i, o) {\n        let t = _ref11.scrapeMotionValuesFromProps,\n          e = _ref11.createRenderState,\n          n = _ref11.onMount;\n        const r = {\n          latestValues: ne(s, i, o, t),\n          renderState: e()\n        };\n        return n && (r.mount = t => n(s, t, r)), r;\n      }(t, n, i, o);\n    return s ? r() : Jt(r);\n  };\n  function ne(t, e, n, s) {\n    const i = {},\n      o = s(t, {});\n    for (const t in o) i[t] = te(o[t]);\n    let r = t.initial,\n      a = t.animate;\n    const l = B(t),\n      u = F(t);\n    e && u && !l && !1 !== t.inherit && (void 0 === r && (r = e.initial), void 0 === a && (a = e.animate));\n    let c = !!n && !1 === n.initial;\n    c = c || !1 === r;\n    const h = c ? a : r;\n    if (h && \"boolean\" != typeof h && !D(h)) {\n      (Array.isArray(h) ? h : [h]).forEach(e => {\n        const n = Zt(t, e);\n        if (!n) return;\n        const s = n.transitionEnd,\n          o = n.transition,\n          r = _objectWithoutProperties(n, _excluded2);\n        for (const t in r) {\n          let e = r[t];\n          if (Array.isArray(e)) {\n            e = e[c ? e.length - 1 : 0];\n          }\n          null !== e && (i[t] = e);\n        }\n        for (const t in s) i[t] = s[t];\n      });\n    }\n    return i;\n  }\n  const se = t => t,\n    _A2 = A(\"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : se, !0),\n    ie = _A2.schedule,\n    oe = _A2.cancel,\n    re = _A2.state,\n    ae = _A2.steps,\n    le = {\n      useVisualState: ee({\n        scrapeMotionValuesFromProps: qt,\n        createRenderState: zt,\n        onMount: (t, e, _ref12) => {\n          let n = _ref12.renderState,\n            s = _ref12.latestValues;\n          ie.read(() => {\n            try {\n              n.dimensions = \"function\" == typeof e.getBBox ? e.getBBox() : e.getBoundingClientRect();\n            } catch (t) {\n              n.dimensions = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              };\n            }\n          }), ie.render(() => {\n            Nt(n, s, {\n              enableHardwareAcceleration: !1\n            }, Ht(e.tagName), t.transformTemplate), Gt(e, n);\n          });\n        }\n      })\n    },\n    ue = {\n      useVisualState: ee({\n        scrapeMotionValuesFromProps: _t,\n        createRenderState: Mt\n      })\n    };\n  function ce(t, _ref13, n, s) {\n    let _ref13$forwardMotionP = _ref13.forwardMotionProps,\n      e = _ref13$forwardMotionP === void 0 ? !1 : _ref13$forwardMotionP;\n    return _objectSpread(_objectSpread({}, G(t) ? le : ue), {}, {\n      preloadedFeatures: n,\n      useRender: Yt(e),\n      createVisualElement: s,\n      Component: t\n    });\n  }\n  function he(t, e, n) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      passive: !0\n    };\n    return t.addEventListener(e, n, s), () => t.removeEventListener(e, n);\n  }\n  const de = t => \"mouse\" === t.pointerType ? \"number\" != typeof t.button || t.button <= 0 : !1 !== t.isPrimary;\n  function me(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"page\";\n    return {\n      point: {\n        x: t[e + \"X\"],\n        y: t[e + \"Y\"]\n      }\n    };\n  }\n  const pe = t => e => de(e) && t(e, me(e));\n  function fe(t, e, n, s) {\n    return he(t, e, pe(n), s);\n  }\n  const ge = (t, e) => n => e(t(n)),\n    ye = function () {\n      for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {\n        t[_key] = arguments[_key];\n      }\n      return t.reduce(ge);\n    };\n  function ve(t) {\n    let e = null;\n    return () => {\n      const n = () => {\n        e = null;\n      };\n      return null === e && (e = t, n);\n    };\n  }\n  const xe = ve(\"dragHorizontal\"),\n    Pe = ve(\"dragVertical\");\n  function we(t) {\n    let e = !1;\n    if (\"y\" === t) e = Pe();else if (\"x\" === t) e = xe();else {\n      const t = xe(),\n        n = Pe();\n      t && n ? e = () => {\n        t(), n();\n      } : (t && t(), n && n());\n    }\n    return e;\n  }\n  function Te() {\n    const t = we(!0);\n    return !t || (t(), !1);\n  }\n  class Se {\n    constructor(t) {\n      this.isMounted = !1, this.node = t;\n    }\n    update() {}\n  }\n  function be(t, e) {\n    const n = e ? \"pointerenter\" : \"pointerleave\",\n      s = e ? \"onHoverStart\" : \"onHoverEnd\";\n    return fe(t.current, n, (n, i) => {\n      if (\"touch\" === n.pointerType || Te()) return;\n      const o = t.getProps();\n      t.animationState && o.whileHover && t.animationState.setActive(\"whileHover\", e);\n      const r = o[s];\n      r && ie.postRender(() => r(n, i));\n    }, {\n      passive: !t.getProps()[s]\n    });\n  }\n  const Ae = (t, e) => !!e && (t === e || Ae(t, e.parentElement));\n  function Ee(t, e) {\n    if (!e) return;\n    const n = new PointerEvent(\"pointer\" + t);\n    e(n, me(n));\n  }\n  const Ce = new WeakMap(),\n    Ve = new WeakMap(),\n    Me = t => {\n      const e = Ce.get(t.target);\n      e && e(t);\n    },\n    Re = t => {\n      t.forEach(Me);\n    };\n  function De(t, e, n) {\n    const s = function (_ref14) {\n      let t = _ref14.root,\n        e = _objectWithoutProperties(_ref14, _excluded3);\n      const n = t || document;\n      Ve.has(n) || Ve.set(n, {});\n      const s = Ve.get(n),\n        i = JSON.stringify(e);\n      return s[i] || (s[i] = new IntersectionObserver(Re, _objectSpread({\n        root: t\n      }, e))), s[i];\n    }(e);\n    return Ce.set(t, n), s.observe(t), () => {\n      Ce.delete(t), s.unobserve(t);\n    };\n  }\n  const ke = {\n    some: 0,\n    all: 1\n  };\n  const Le = {\n    inView: {\n      Feature: class extends Se {\n        constructor() {\n          super(...arguments), this.hasEnteredView = !1, this.isInView = !1;\n        }\n        startObserver() {\n          this.unmount();\n          const _this$node$getProps = this.node.getProps(),\n            _this$node$getProps$v = _this$node$getProps.viewport,\n            t = _this$node$getProps$v === void 0 ? {} : _this$node$getProps$v,\n            e = t.root,\n            n = t.margin,\n            _t$amount = t.amount,\n            s = _t$amount === void 0 ? \"some\" : _t$amount,\n            i = t.once,\n            o = {\n              root: e ? e.current : void 0,\n              rootMargin: n,\n              threshold: \"number\" == typeof s ? s : ke[s]\n            };\n          return De(this.node.current, o, t => {\n            const e = t.isIntersecting;\n            if (this.isInView === e) return;\n            if (this.isInView = e, i && !e && this.hasEnteredView) return;\n            e && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive(\"whileInView\", e);\n            const _this$node$getProps2 = this.node.getProps(),\n              n = _this$node$getProps2.onViewportEnter,\n              s = _this$node$getProps2.onViewportLeave,\n              o = e ? n : s;\n            o && o(t);\n          });\n        }\n        mount() {\n          this.startObserver();\n        }\n        update() {\n          if (\"undefined\" == typeof IntersectionObserver) return;\n          const _this$node = this.node,\n            t = _this$node.props,\n            e = _this$node.prevProps;\n          [\"amount\", \"margin\", \"root\"].some(function (_ref15) {\n            let _ref15$viewport = _ref15.viewport,\n              t = _ref15$viewport === void 0 ? {} : _ref15$viewport;\n            let _ref16 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n              _ref16$viewport = _ref16.viewport,\n              e = _ref16$viewport === void 0 ? {} : _ref16$viewport;\n            return n => t[n] !== e[n];\n          }(t, e)) && this.startObserver();\n        }\n        unmount() {}\n      }\n    },\n    tap: {\n      Feature: class extends Se {\n        constructor() {\n          super(...arguments), this.removeStartListeners = se, this.removeEndListeners = se, this.removeAccessibleListeners = se, this.startPointerPress = (t, e) => {\n            if (this.isPressing) return;\n            this.removeEndListeners();\n            const n = this.node.getProps(),\n              s = fe(window, \"pointerup\", (t, e) => {\n                if (!this.checkPressEnd()) return;\n                const _this$node$getProps3 = this.node.getProps(),\n                  n = _this$node$getProps3.onTap,\n                  s = _this$node$getProps3.onTapCancel,\n                  i = _this$node$getProps3.globalTapTarget,\n                  o = i || Ae(this.node.current, t.target) ? n : s;\n                o && ie.update(() => o(t, e));\n              }, {\n                passive: !(n.onTap || n.onPointerUp)\n              }),\n              i = fe(window, \"pointercancel\", (t, e) => this.cancelPress(t, e), {\n                passive: !(n.onTapCancel || n.onPointerCancel)\n              });\n            this.removeEndListeners = ye(s, i), this.startPress(t, e);\n          }, this.startAccessiblePress = () => {\n            const t = he(this.node.current, \"keydown\", t => {\n                if (\"Enter\" !== t.key || this.isPressing) return;\n                this.removeEndListeners(), this.removeEndListeners = he(this.node.current, \"keyup\", t => {\n                  \"Enter\" === t.key && this.checkPressEnd() && Ee(\"up\", (t, e) => {\n                    const _this$node$getProps4 = this.node.getProps(),\n                      n = _this$node$getProps4.onTap;\n                    n && ie.postRender(() => n(t, e));\n                  });\n                }), Ee(\"down\", (t, e) => {\n                  this.startPress(t, e);\n                });\n              }),\n              e = he(this.node.current, \"blur\", () => {\n                this.isPressing && Ee(\"cancel\", (t, e) => this.cancelPress(t, e));\n              });\n            this.removeAccessibleListeners = ye(t, e);\n          };\n        }\n        startPress(t, e) {\n          this.isPressing = !0;\n          const _this$node$getProps5 = this.node.getProps(),\n            n = _this$node$getProps5.onTapStart,\n            s = _this$node$getProps5.whileTap;\n          s && this.node.animationState && this.node.animationState.setActive(\"whileTap\", !0), n && ie.postRender(() => n(t, e));\n        }\n        checkPressEnd() {\n          this.removeEndListeners(), this.isPressing = !1;\n          return this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive(\"whileTap\", !1), !Te();\n        }\n        cancelPress(t, e) {\n          if (!this.checkPressEnd()) return;\n          const _this$node$getProps6 = this.node.getProps(),\n            n = _this$node$getProps6.onTapCancel;\n          n && ie.postRender(() => n(t, e));\n        }\n        mount() {\n          const t = this.node.getProps(),\n            e = fe(t.globalTapTarget ? window : this.node.current, \"pointerdown\", this.startPointerPress, {\n              passive: !(t.onTapStart || t.onPointerStart)\n            }),\n            n = he(this.node.current, \"focus\", this.startAccessiblePress);\n          this.removeStartListeners = ye(e, n);\n        }\n        unmount() {\n          this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();\n        }\n      }\n    },\n    focus: {\n      Feature: class extends Se {\n        constructor() {\n          super(...arguments), this.isActive = !1;\n        }\n        onFocus() {\n          let t = !1;\n          try {\n            t = this.node.current.matches(\":focus-visible\");\n          } catch (e) {\n            t = !0;\n          }\n          t && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !0), this.isActive = !0);\n        }\n        onBlur() {\n          this.isActive && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !1), this.isActive = !1);\n        }\n        mount() {\n          this.unmount = ye(he(this.node.current, \"focus\", () => this.onFocus()), he(this.node.current, \"blur\", () => this.onBlur()));\n        }\n        unmount() {}\n      }\n    },\n    hover: {\n      Feature: class extends Se {\n        mount() {\n          this.unmount = ye(be(this.node, !0), be(this.node, !1));\n        }\n        unmount() {}\n      }\n    }\n  };\n  function Be(t, e) {\n    if (!Array.isArray(e)) return !1;\n    const n = e.length;\n    if (n !== t.length) return !1;\n    for (let s = 0; s < n; s++) if (e[s] !== t[s]) return !1;\n    return !0;\n  }\n  function Fe(t, e, n) {\n    const s = t.getProps();\n    return Zt(s, e, void 0 !== n ? n : s.custom, function (t) {\n      const e = {};\n      return t.values.forEach((t, n) => e[n] = t.get()), e;\n    }(t), function (t) {\n      const e = {};\n      return t.values.forEach((t, n) => e[n] = t.getVelocity()), e;\n    }(t));\n  }\n  const je = t => 1e3 * t,\n    Oe = t => t / 1e3,\n    Ie = {\n      type: \"spring\",\n      stiffness: 500,\n      damping: 25,\n      restSpeed: 10\n    },\n    Ue = {\n      type: \"keyframes\",\n      duration: .8\n    },\n    We = {\n      type: \"keyframes\",\n      ease: [.25, .1, .35, 1],\n      duration: .3\n    },\n    Ne = (t, _ref17) => {\n      let e = _ref17.keyframes;\n      return e.length > 2 ? Ue : J.has(t) ? t.startsWith(\"scale\") ? {\n        type: \"spring\",\n        stiffness: 550,\n        damping: 0 === e[1] ? 2 * Math.sqrt(550) : 30,\n        restSpeed: 10\n      } : Ie : We;\n    };\n  function ze(t, e) {\n    return t[e] || t.default || t;\n  }\n  const He = {\n      current: !1\n    },\n    $e = t => null !== t;\n  function Ye(t, _ref18, s) {\n    let e = _ref18.repeat,\n      _ref18$repeatType = _ref18.repeatType,\n      n = _ref18$repeatType === void 0 ? \"loop\" : _ref18$repeatType;\n    const i = t.filter($e),\n      o = e && \"loop\" !== n && e % 2 == 1 ? 0 : i.length - 1;\n    return o && void 0 !== s ? s : i[o];\n  }\n  let Xe;\n  function Ke() {\n    Xe = void 0;\n  }\n  const Ge = {\n      now: () => (void 0 === Xe && Ge.set(re.isProcessing || T.useManualTiming ? re.timestamp : performance.now()), Xe),\n      set: t => {\n        Xe = t, queueMicrotask(Ke);\n      }\n    },\n    _e = t => /^0[^.\\s]+$/u.test(t);\n  let qe = se,\n    Ze = se;\n  const Je = t => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(t),\n    Qe = /^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\n  function tn(t, e) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const _ref19 = function (t) {\n        const e = Qe.exec(t);\n        if (!e) return [,];\n        const _e2 = _slicedToArray(e, 4),\n          n = _e2[1],\n          s = _e2[2],\n          i = _e2[3];\n        return [\"--\" + (null != n ? n : s), i];\n      }(t),\n      _ref20 = _slicedToArray(_ref19, 2),\n      s = _ref20[0],\n      i = _ref20[1];\n    if (!s) return;\n    const o = window.getComputedStyle(e).getPropertyValue(s);\n    if (o) {\n      const t = o.trim();\n      return Je(t) ? parseFloat(t) : t;\n    }\n    return at(i) ? tn(i, e, n + 1) : i;\n  }\n  const en = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\", \"translateX\", \"translateY\"]),\n    nn = t => t === ht || t === Tt,\n    sn = (t, e) => parseFloat(t.split(\", \")[e]),\n    on = (t, e) => (n, _ref21) => {\n      let s = _ref21.transform;\n      if (\"none\" === s || !s) return 0;\n      const i = s.match(/^matrix3d\\((.+)\\)$/u);\n      if (i) return sn(i[1], e);\n      {\n        const e = s.match(/^matrix\\((.+)\\)$/u);\n        return e ? sn(e[1], t) : 0;\n      }\n    },\n    rn = new Set([\"x\", \"y\", \"z\"]),\n    an = Z.filter(t => !rn.has(t));\n  const ln = {\n    width: (_ref22, _ref23) => {\n      let t = _ref22.x;\n      let _ref23$paddingLeft = _ref23.paddingLeft,\n        e = _ref23$paddingLeft === void 0 ? \"0\" : _ref23$paddingLeft,\n        _ref23$paddingRight = _ref23.paddingRight,\n        n = _ref23$paddingRight === void 0 ? \"0\" : _ref23$paddingRight;\n      return t.max - t.min - parseFloat(e) - parseFloat(n);\n    },\n    height: (_ref24, _ref25) => {\n      let t = _ref24.y;\n      let _ref25$paddingTop = _ref25.paddingTop,\n        e = _ref25$paddingTop === void 0 ? \"0\" : _ref25$paddingTop,\n        _ref25$paddingBottom = _ref25.paddingBottom,\n        n = _ref25$paddingBottom === void 0 ? \"0\" : _ref25$paddingBottom;\n      return t.max - t.min - parseFloat(e) - parseFloat(n);\n    },\n    top: (t, _ref26) => {\n      let e = _ref26.top;\n      return parseFloat(e);\n    },\n    left: (t, _ref27) => {\n      let e = _ref27.left;\n      return parseFloat(e);\n    },\n    bottom: (_ref28, _ref29) => {\n      let t = _ref28.y;\n      let e = _ref29.top;\n      return parseFloat(e) + (t.max - t.min);\n    },\n    right: (_ref30, _ref31) => {\n      let t = _ref30.x;\n      let e = _ref31.left;\n      return parseFloat(e) + (t.max - t.min);\n    },\n    x: on(4, 13),\n    y: on(5, 14)\n  };\n  ln.translateX = ln.x, ln.translateY = ln.y;\n  const un = t => e => e.test(t),\n    cn = [ht, Tt, wt, Pt, bt, St, {\n      test: t => \"auto\" === t,\n      parse: t => t\n    }],\n    hn = t => cn.find(un(t)),\n    dn = new Set();\n  let mn = !1,\n    pn = !1;\n  function fn() {\n    if (pn) {\n      const t = Array.from(dn).filter(t => t.needsMeasurement),\n        e = new Set(t.map(t => t.element)),\n        n = new Map();\n      e.forEach(t => {\n        const e = function (t) {\n          const e = [];\n          return an.forEach(n => {\n            const s = t.getValue(n);\n            void 0 !== s && (e.push([n, s.get()]), s.set(n.startsWith(\"scale\") ? 1 : 0));\n          }), e;\n        }(t);\n        e.length && (n.set(t, e), t.render());\n      }), t.forEach(t => t.measureInitialState()), e.forEach(t => {\n        t.render();\n        const e = n.get(t);\n        e && e.forEach(_ref32 => {\n          let _ref33 = _slicedToArray(_ref32, 2),\n            e = _ref33[0],\n            n = _ref33[1];\n          var s;\n          null === (s = t.getValue(e)) || void 0 === s || s.set(n);\n        });\n      }), t.forEach(t => t.measureEndState()), t.forEach(t => {\n        void 0 !== t.suspendedScrollY && window.scrollTo(0, t.suspendedScrollY);\n      });\n    }\n    pn = !1, mn = !1, dn.forEach(t => t.complete()), dn.clear();\n  }\n  function gn() {\n    dn.forEach(t => {\n      t.readKeyframes(), t.needsMeasurement && (pn = !0);\n    });\n  }\n  class yn {\n    constructor(t, e, n, s, i) {\n      let o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n      this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = e, this.name = n, this.motionValue = s, this.element = i, this.isAsync = o;\n    }\n    scheduleResolve() {\n      this.isScheduled = !0, this.isAsync ? (dn.add(this), mn || (mn = !0, ie.read(gn), ie.resolveKeyframes(fn))) : (this.readKeyframes(), this.complete());\n    }\n    readKeyframes() {\n      const t = this.unresolvedKeyframes,\n        e = this.name,\n        n = this.element,\n        s = this.motionValue;\n      for (let i = 0; i < t.length; i++) if (null === t[i]) if (0 === i) {\n        const i = null == s ? void 0 : s.get(),\n          o = t[t.length - 1];\n        if (void 0 !== i) t[0] = i;else if (n && e) {\n          const s = n.readValue(e, o);\n          null != s && (t[0] = s);\n        }\n        void 0 === t[0] && (t[0] = o), s && void 0 === i && s.set(t[0]);\n      } else t[i] = t[i - 1];\n    }\n    setFinalKeyframe() {}\n    measureInitialState() {}\n    renderEndStyles() {}\n    measureEndState() {}\n    complete() {\n      this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), dn.delete(this);\n    }\n    cancel() {\n      this.isComplete || (this.isScheduled = !1, dn.delete(this));\n    }\n    resume() {\n      this.isComplete || this.scheduleResolve();\n    }\n  }\n  const vn = (t, e) => n => Boolean(vt(n) && yt.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)),\n    xn = (t, e, n) => s => {\n      if (!vt(s)) return s;\n      const _s$match = s.match(ft),\n        _s$match2 = _slicedToArray(_s$match, 4),\n        i = _s$match2[0],\n        o = _s$match2[1],\n        r = _s$match2[2],\n        a = _s$match2[3];\n      return {\n        [t]: parseFloat(i),\n        [e]: parseFloat(o),\n        [n]: parseFloat(r),\n        alpha: void 0 !== a ? parseFloat(a) : 1\n      };\n    },\n    Pn = _objectSpread(_objectSpread({}, ht), {}, {\n      transform: t => Math.round((t => ct(0, 255, t))(t))\n    }),\n    wn = {\n      test: vn(\"rgb\", \"red\"),\n      parse: xn(\"red\", \"green\", \"blue\"),\n      transform: _ref34 => {\n        let t = _ref34.red,\n          e = _ref34.green,\n          n = _ref34.blue,\n          _ref34$alpha = _ref34.alpha,\n          s = _ref34$alpha === void 0 ? 1 : _ref34$alpha;\n        return \"rgba(\" + Pn.transform(t) + \", \" + Pn.transform(e) + \", \" + Pn.transform(n) + \", \" + pt(dt.transform(s)) + \")\";\n      }\n    };\n  const Tn = {\n      test: vn(\"#\"),\n      parse: function (t) {\n        let e = \"\",\n          n = \"\",\n          s = \"\",\n          i = \"\";\n        return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), s = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), s = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, s += s, i += i), {\n          red: parseInt(e, 16),\n          green: parseInt(n, 16),\n          blue: parseInt(s, 16),\n          alpha: i ? parseInt(i, 16) / 255 : 1\n        };\n      },\n      transform: wn.transform\n    },\n    Sn = {\n      test: vn(\"hsl\", \"hue\"),\n      parse: xn(\"hue\", \"saturation\", \"lightness\"),\n      transform: _ref35 => {\n        let t = _ref35.hue,\n          e = _ref35.saturation,\n          n = _ref35.lightness,\n          _ref35$alpha = _ref35.alpha,\n          s = _ref35$alpha === void 0 ? 1 : _ref35$alpha;\n        return \"hsla(\" + Math.round(t) + \", \" + wt.transform(pt(e)) + \", \" + wt.transform(pt(n)) + \", \" + pt(dt.transform(s)) + \")\";\n      }\n    },\n    bn = {\n      test: t => wn.test(t) || Tn.test(t) || Sn.test(t),\n      parse: t => wn.test(t) ? wn.parse(t) : Sn.test(t) ? Sn.parse(t) : Tn.parse(t),\n      transform: t => vt(t) ? t : t.hasOwnProperty(\"red\") ? wn.transform(t) : Sn.transform(t)\n    };\n  const An = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\n  function En(t) {\n    const e = t.toString(),\n      n = [],\n      s = {\n        color: [],\n        number: [],\n        var: []\n      },\n      i = [];\n    let o = 0;\n    const r = e.replace(An, t => (bn.test(t) ? (s.color.push(o), i.push(\"color\"), n.push(bn.parse(t))) : t.startsWith(\"var(\") ? (s.var.push(o), i.push(\"var\"), n.push(t)) : (s.number.push(o), i.push(\"number\"), n.push(parseFloat(t))), ++o, \"${}\")).split(\"${}\");\n    return {\n      values: n,\n      split: r,\n      indexes: s,\n      types: i\n    };\n  }\n  function Cn(t) {\n    return En(t).values;\n  }\n  function Vn(t) {\n    const _En = En(t),\n      e = _En.split,\n      n = _En.types,\n      s = e.length;\n    return t => {\n      let i = \"\";\n      for (let o = 0; o < s; o++) if (i += e[o], void 0 !== t[o]) {\n        const e = n[o];\n        i += \"number\" === e ? pt(t[o]) : \"color\" === e ? bn.transform(t[o]) : t[o];\n      }\n      return i;\n    };\n  }\n  const Mn = t => \"number\" == typeof t ? 0 : t;\n  const Rn = {\n      test: function (t) {\n        var e, n;\n        return isNaN(t) && vt(t) && ((null === (e = t.match(ft)) || void 0 === e ? void 0 : e.length) || 0) + ((null === (n = t.match(gt)) || void 0 === n ? void 0 : n.length) || 0) > 0;\n      },\n      parse: Cn,\n      createTransformer: Vn,\n      getAnimatableNone: function (t) {\n        const e = Cn(t);\n        return Vn(t)(e.map(Mn));\n      }\n    },\n    Dn = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\n  function kn(t) {\n    const _t$slice$split = t.slice(0, -1).split(\"(\"),\n      _t$slice$split2 = _slicedToArray(_t$slice$split, 2),\n      e = _t$slice$split2[0],\n      n = _t$slice$split2[1];\n    if (\"drop-shadow\" === e) return t;\n    const _ref36 = n.match(ft) || [],\n      _ref37 = _slicedToArray(_ref36, 1),\n      s = _ref37[0];\n    if (!s) return t;\n    const i = n.replace(s, \"\");\n    let o = Dn.has(e) ? 1 : 0;\n    return s !== n && (o *= 100), e + \"(\" + o + i + \")\";\n  }\n  const Ln = /\\b([a-z-]*)\\(.*?\\)/gu,\n    Bn = _objectSpread(_objectSpread({}, Rn), {}, {\n      getAnimatableNone: t => {\n        const e = t.match(Ln);\n        return e ? e.map(kn).join(\" \") : t;\n      }\n    }),\n    Fn = _objectSpread(_objectSpread({}, Ct), {}, {\n      color: bn,\n      backgroundColor: bn,\n      outlineColor: bn,\n      fill: bn,\n      stroke: bn,\n      borderColor: bn,\n      borderTopColor: bn,\n      borderRightColor: bn,\n      borderBottomColor: bn,\n      borderLeftColor: bn,\n      filter: Bn,\n      WebkitFilter: Bn\n    }),\n    jn = t => Fn[t];\n  function On(t, e) {\n    let n = jn(t);\n    return n !== Bn && (n = Rn), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;\n  }\n  const In = new Set([\"auto\", \"none\", \"0\"]);\n  class Un extends yn {\n    constructor(t, e, n, s) {\n      super(t, e, n, s, null == s ? void 0 : s.owner, !0);\n    }\n    readKeyframes() {\n      const t = this.unresolvedKeyframes,\n        e = this.element,\n        n = this.name;\n      if (!e.current) return;\n      super.readKeyframes();\n      for (let n = 0; n < t.length; n++) {\n        const s = t[n];\n        if (\"string\" == typeof s && at(s)) {\n          const i = tn(s, e.current);\n          void 0 !== i && (t[n] = i), n === t.length - 1 && (this.finalKeyframe = s);\n        }\n      }\n      if (this.resolveNoneKeyframes(), !en.has(n) || 2 !== t.length) return;\n      const _t2 = _slicedToArray(t, 2),\n        s = _t2[0],\n        i = _t2[1],\n        o = hn(s),\n        r = hn(i);\n      if (o !== r) if (nn(o) && nn(r)) for (let e = 0; e < t.length; e++) {\n        const n = t[e];\n        \"string\" == typeof n && (t[e] = parseFloat(n));\n      } else this.needsMeasurement = !0;\n    }\n    resolveNoneKeyframes() {\n      const t = this.unresolvedKeyframes,\n        e = this.name,\n        n = [];\n      for (let e = 0; e < t.length; e++) (\"number\" == typeof (s = t[e]) ? 0 === s : null === s || \"none\" === s || \"0\" === s || _e(s)) && n.push(e);\n      var s;\n      n.length && function (t, e, n) {\n        let s = 0,\n          i = void 0;\n        for (; s < t.length && !i;) {\n          const e = t[s];\n          \"string\" == typeof e && !In.has(e) && En(e).values.length && (i = t[s]), s++;\n        }\n        if (i && n) for (const s of e) t[s] = On(n, i);\n      }(t, n, e);\n    }\n    measureInitialState() {\n      const t = this.element,\n        e = this.unresolvedKeyframes,\n        n = this.name;\n      if (!t.current) return;\n      \"height\" === n && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ln[n](t.measureViewportBox(), window.getComputedStyle(t.current)), e[0] = this.measuredOrigin;\n      const s = e[e.length - 1];\n      void 0 !== s && t.getValue(n, s).jump(s, !1);\n    }\n    measureEndState() {\n      var t;\n      const e = this.element,\n        n = this.name,\n        s = this.unresolvedKeyframes;\n      if (!e.current) return;\n      const i = e.getValue(n);\n      i && i.jump(this.measuredOrigin, !1);\n      const o = s.length - 1,\n        r = s[o];\n      s[o] = ln[n](e.measureViewportBox(), window.getComputedStyle(e.current)), null !== r && void 0 === this.finalKeyframe && (this.finalKeyframe = r), (null === (t = this.removedTransforms) || void 0 === t ? void 0 : t.length) && this.removedTransforms.forEach(_ref38 => {\n        let _ref39 = _slicedToArray(_ref38, 2),\n          t = _ref39[0],\n          n = _ref39[1];\n        e.getValue(t).set(n);\n      }), this.resolveNoneKeyframes();\n    }\n  }\n  function Wn(t) {\n    let e;\n    return () => (void 0 === e && (e = t()), e);\n  }\n  const Nn = (t, e) => \"zIndex\" !== e && (!(\"number\" != typeof t && !Array.isArray(t)) || !(\"string\" != typeof t || !Rn.test(t) && \"0\" !== t || t.startsWith(\"url(\")));\n  class zn {\n    constructor(_ref40) {\n      let _ref40$autoplay = _ref40.autoplay,\n        t = _ref40$autoplay === void 0 ? !0 : _ref40$autoplay,\n        _ref40$delay = _ref40.delay,\n        e = _ref40$delay === void 0 ? 0 : _ref40$delay,\n        _ref40$type = _ref40.type,\n        n = _ref40$type === void 0 ? \"keyframes\" : _ref40$type,\n        _ref40$repeat = _ref40.repeat,\n        s = _ref40$repeat === void 0 ? 0 : _ref40$repeat,\n        _ref40$repeatDelay = _ref40.repeatDelay,\n        i = _ref40$repeatDelay === void 0 ? 0 : _ref40$repeatDelay,\n        _ref40$repeatType = _ref40.repeatType,\n        o = _ref40$repeatType === void 0 ? \"loop\" : _ref40$repeatType,\n        r = _objectWithoutProperties(_ref40, _excluded4);\n      this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = _objectSpread({\n        autoplay: t,\n        delay: e,\n        type: n,\n        repeat: s,\n        repeatDelay: i,\n        repeatType: o\n      }, r), this.updateFinishedPromise();\n    }\n    get resolved() {\n      return this._resolved || this.hasAttemptedResolve || (gn(), fn()), this._resolved;\n    }\n    onKeyframesResolved(t, e) {\n      this.hasAttemptedResolve = !0;\n      const _this$options = this.options,\n        n = _this$options.name,\n        s = _this$options.type,\n        i = _this$options.velocity,\n        o = _this$options.delay,\n        r = _this$options.onComplete,\n        a = _this$options.onUpdate,\n        l = _this$options.isGenerator;\n      if (!l && !function (t, e, n, s) {\n        const i = t[0];\n        if (null === i) return !1;\n        if (\"display\" === e || \"visibility\" === e) return !0;\n        const o = t[t.length - 1],\n          r = Nn(i, e),\n          a = Nn(o, e);\n        return !(!r || !a) && (function (t) {\n          const e = t[0];\n          if (1 === t.length) return !0;\n          for (let n = 0; n < t.length; n++) if (t[n] !== e) return !0;\n        }(t) || \"spring\" === n && s);\n      }(t, n, s, i)) {\n        if (He.current || !o) return null == a || a(Ye(t, this.options, e)), null == r || r(), void this.resolveFinishedPromise();\n        this.options.duration = 0;\n      }\n      const u = this.initPlayback(t, e);\n      !1 !== u && (this._resolved = _objectSpread({\n        keyframes: t,\n        finalKeyframe: e\n      }, u), this.onPostResolved());\n    }\n    onPostResolved() {}\n    then(t, e) {\n      return this.currentFinishedPromise.then(t, e);\n    }\n    updateFinishedPromise() {\n      this.currentFinishedPromise = new Promise(t => {\n        this.resolveFinishedPromise = t;\n      });\n    }\n  }\n  function Hn(t, e) {\n    return e ? t * (1e3 / e) : 0;\n  }\n  function $n(t, e, n) {\n    const s = Math.max(e - 5, 0);\n    return Hn(n - t(s), e - s);\n  }\n  function Yn(_ref41) {\n    let _ref41$duration = _ref41.duration,\n      t = _ref41$duration === void 0 ? 800 : _ref41$duration,\n      _ref41$bounce = _ref41.bounce,\n      e = _ref41$bounce === void 0 ? .25 : _ref41$bounce,\n      _ref41$velocity = _ref41.velocity,\n      n = _ref41$velocity === void 0 ? 0 : _ref41$velocity,\n      _ref41$mass = _ref41.mass,\n      s = _ref41$mass === void 0 ? 1 : _ref41$mass;\n    let i,\n      o,\n      r = 1 - e;\n    r = ct(.05, 1, r), t = ct(.01, 10, Oe(t)), r < 1 ? (i = e => {\n      const s = e * r,\n        i = s * t;\n      return .001 - (s - n) / Xn(e, r) * Math.exp(-i);\n    }, o = e => {\n      const s = e * r * t,\n        o = s * n + n,\n        a = Math.pow(r, 2) * Math.pow(e, 2) * t,\n        l = Math.exp(-s),\n        u = Xn(Math.pow(e, 2), r);\n      return (.001 - i(e) > 0 ? -1 : 1) * ((o - a) * l) / u;\n    }) : (i = e => Math.exp(-e * t) * ((e - n) * t + 1) - .001, o = e => Math.exp(-e * t) * (t * t * (n - e)));\n    const a = function (t, e, n) {\n      let s = n;\n      for (let n = 1; n < 12; n++) s -= t(s) / e(s);\n      return s;\n    }(i, o, 5 / t);\n    if (t = je(t), isNaN(a)) return {\n      stiffness: 100,\n      damping: 10,\n      duration: t\n    };\n    {\n      const e = Math.pow(a, 2) * s;\n      return {\n        stiffness: e,\n        damping: 2 * r * Math.sqrt(s * e),\n        duration: t\n      };\n    }\n  }\n  function Xn(t, e) {\n    return t * Math.sqrt(1 - e * e);\n  }\n  const Kn = [\"duration\", \"bounce\"],\n    Gn = [\"stiffness\", \"damping\", \"mass\"];\n  function _n(t, e) {\n    return e.some(e => void 0 !== t[e]);\n  }\n  function qn(_ref42) {\n    let t = _ref42.keyframes,\n      e = _ref42.restDelta,\n      n = _ref42.restSpeed,\n      s = _objectWithoutProperties(_ref42, _excluded5);\n    const i = t[0],\n      o = t[t.length - 1],\n      r = {\n        done: !1,\n        value: i\n      },\n      _ref43 = function (t) {\n        let e = _objectSpread({\n          velocity: 0,\n          stiffness: 100,\n          damping: 10,\n          mass: 1,\n          isResolvedFromDuration: !1\n        }, t);\n        if (!_n(t, Gn) && _n(t, Kn)) {\n          const n = Yn(t);\n          e = _objectSpread(_objectSpread(_objectSpread({}, e), n), {}, {\n            mass: 1\n          }), e.isResolvedFromDuration = !0;\n        }\n        return e;\n      }(_objectSpread(_objectSpread({}, s), {}, {\n        velocity: -Oe(s.velocity || 0)\n      })),\n      a = _ref43.stiffness,\n      l = _ref43.damping,\n      u = _ref43.mass,\n      c = _ref43.duration,\n      h = _ref43.velocity,\n      d = _ref43.isResolvedFromDuration,\n      m = h || 0,\n      p = l / (2 * Math.sqrt(a * u)),\n      f = o - i,\n      g = Oe(Math.sqrt(a / u)),\n      y = Math.abs(f) < 5;\n    let v;\n    if (n || (n = y ? .01 : 2), e || (e = y ? .005 : .5), p < 1) {\n      const t = Xn(g, p);\n      v = e => {\n        const n = Math.exp(-p * g * e);\n        return o - n * ((m + p * g * f) / t * Math.sin(t * e) + f * Math.cos(t * e));\n      };\n    } else if (1 === p) v = t => o - Math.exp(-g * t) * (f + (m + g * f) * t);else {\n      const t = g * Math.sqrt(p * p - 1);\n      v = e => {\n        const n = Math.exp(-p * g * e),\n          s = Math.min(t * e, 300);\n        return o - n * ((m + p * g * f) * Math.sinh(s) + t * f * Math.cosh(s)) / t;\n      };\n    }\n    return {\n      calculatedDuration: d && c || null,\n      next: t => {\n        const s = v(t);\n        if (d) r.done = t >= c;else {\n          let i = m;\n          0 !== t && (i = p < 1 ? $n(v, t, s) : 0);\n          const a = Math.abs(i) <= n,\n            l = Math.abs(o - s) <= e;\n          r.done = a && l;\n        }\n        return r.value = r.done ? o : s, r;\n      }\n    };\n  }\n  function Zn(_ref44) {\n    let t = _ref44.keyframes,\n      _ref44$velocity = _ref44.velocity,\n      e = _ref44$velocity === void 0 ? 0 : _ref44$velocity,\n      _ref44$power = _ref44.power,\n      n = _ref44$power === void 0 ? .8 : _ref44$power,\n      _ref44$timeConstant = _ref44.timeConstant,\n      s = _ref44$timeConstant === void 0 ? 325 : _ref44$timeConstant,\n      _ref44$bounceDamping = _ref44.bounceDamping,\n      i = _ref44$bounceDamping === void 0 ? 10 : _ref44$bounceDamping,\n      _ref44$bounceStiffnes = _ref44.bounceStiffness,\n      o = _ref44$bounceStiffnes === void 0 ? 500 : _ref44$bounceStiffnes,\n      r = _ref44.modifyTarget,\n      a = _ref44.min,\n      l = _ref44.max,\n      _ref44$restDelta = _ref44.restDelta,\n      u = _ref44$restDelta === void 0 ? .5 : _ref44$restDelta,\n      c = _ref44.restSpeed;\n    const h = t[0],\n      d = {\n        done: !1,\n        value: h\n      },\n      m = t => void 0 === a ? l : void 0 === l || Math.abs(a - t) < Math.abs(l - t) ? a : l;\n    let p = n * e;\n    const f = h + p,\n      g = void 0 === r ? f : r(f);\n    g !== f && (p = g - h);\n    const y = t => -p * Math.exp(-t / s),\n      v = t => g + y(t),\n      x = t => {\n        const e = y(t),\n          n = v(t);\n        d.done = Math.abs(e) <= u, d.value = d.done ? g : n;\n      };\n    let P, w;\n    const T = t => {\n      var e;\n      (e = d.value, void 0 !== a && e < a || void 0 !== l && e > l) && (P = t, w = qn({\n        keyframes: [d.value, m(d.value)],\n        velocity: $n(v, t, d.value),\n        damping: i,\n        stiffness: o,\n        restDelta: u,\n        restSpeed: c\n      }));\n    };\n    return T(0), {\n      calculatedDuration: null,\n      next: t => {\n        let e = !1;\n        return w || void 0 !== P || (e = !0, x(t), T(t)), void 0 !== P && t >= P ? w.next(t - P) : (!e && x(t), d);\n      }\n    };\n  }\n  const Jn = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t;\n  function Qn(t, e, n, s) {\n    if (t === e && n === s) return se;\n    const i = e => function (t, e, n, s, i) {\n      let o,\n        r,\n        a = 0;\n      do {\n        r = e + (n - e) / 2, o = Jn(r, s, i) - t, o > 0 ? n = r : e = r;\n      } while (Math.abs(o) > 1e-7 && ++a < 12);\n      return r;\n    }(e, 0, 1, t, n);\n    return t => 0 === t || 1 === t ? t : Jn(i(t), e, s);\n  }\n  const ts = Qn(.42, 0, 1, 1),\n    es = Qn(0, 0, .58, 1),\n    ns = Qn(.42, 0, .58, 1),\n    ss = t => Array.isArray(t) && \"number\" != typeof t[0],\n    is = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,\n    os = t => e => 1 - t(1 - e),\n    rs = t => 1 - Math.sin(Math.acos(t)),\n    as = os(rs),\n    ls = is(rs),\n    us = Qn(.33, 1.53, .69, .99),\n    cs = os(us),\n    hs = is(cs),\n    ds = t => (t *= 2) < 1 ? .5 * cs(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))),\n    ms = {\n      linear: se,\n      easeIn: ts,\n      easeInOut: ns,\n      easeOut: es,\n      circIn: rs,\n      circInOut: ls,\n      circOut: as,\n      backIn: cs,\n      backInOut: hs,\n      backOut: us,\n      anticipate: ds\n    },\n    ps = t => {\n      if (Array.isArray(t)) {\n        Ze(4 === t.length);\n        const _t3 = _slicedToArray(t, 4),\n          e = _t3[0],\n          n = _t3[1],\n          s = _t3[2],\n          i = _t3[3];\n        return Qn(e, n, s, i);\n      }\n      return \"string\" == typeof t ? ms[t] : t;\n    },\n    fs = (t, e, n) => {\n      const s = e - t;\n      return 0 === s ? 1 : (n - t) / s;\n    },\n    gs = (t, e, n) => t + (e - t) * n;\n  function ys(t, e, n) {\n    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;\n  }\n  const vs = (t, e, n) => {\n      const s = t * t,\n        i = n * (e * e - s) + s;\n      return i < 0 ? 0 : Math.sqrt(i);\n    },\n    xs = [Tn, wn, Sn];\n  function Ps(t) {\n    const e = (n = t, xs.find(t => t.test(n)));\n    var n;\n    let s = e.parse(t);\n    return e === Sn && (s = function (_ref45) {\n      let t = _ref45.hue,\n        e = _ref45.saturation,\n        n = _ref45.lightness,\n        s = _ref45.alpha;\n      t /= 360, n /= 100;\n      let i = 0,\n        o = 0,\n        r = 0;\n      if (e /= 100) {\n        const s = n < .5 ? n * (1 + e) : n + e - n * e,\n          a = 2 * n - s;\n        i = ys(a, s, t + 1 / 3), o = ys(a, s, t), r = ys(a, s, t - 1 / 3);\n      } else i = o = r = n;\n      return {\n        red: Math.round(255 * i),\n        green: Math.round(255 * o),\n        blue: Math.round(255 * r),\n        alpha: s\n      };\n    }(s)), s;\n  }\n  const ws = (t, e) => {\n      const n = Ps(t),\n        s = Ps(e),\n        i = _objectSpread({}, n);\n      return t => (i.red = vs(n.red, s.red, t), i.green = vs(n.green, s.green, t), i.blue = vs(n.blue, s.blue, t), i.alpha = gs(n.alpha, s.alpha, t), wn.transform(i));\n    },\n    Ts = new Set([\"none\", \"hidden\"]);\n  function Ss(t, e) {\n    return n => n > 0 ? e : t;\n  }\n  function bs(t, e) {\n    return n => gs(t, e, n);\n  }\n  function As(t) {\n    return \"number\" == typeof t ? bs : \"string\" == typeof t ? at(t) ? Ss : bn.test(t) ? ws : Vs : Array.isArray(t) ? Es : \"object\" == typeof t ? bn.test(t) ? ws : Cs : Ss;\n  }\n  function Es(t, e) {\n    const n = [...t],\n      s = n.length,\n      i = t.map((t, n) => As(t)(t, e[n]));\n    return t => {\n      for (let e = 0; e < s; e++) n[e] = i[e](t);\n      return n;\n    };\n  }\n  function Cs(t, e) {\n    const n = _objectSpread(_objectSpread({}, t), e),\n      s = {};\n    for (const i in n) void 0 !== t[i] && void 0 !== e[i] && (s[i] = As(t[i])(t[i], e[i]));\n    return t => {\n      for (const e in s) n[e] = s[e](t);\n      return n;\n    };\n  }\n  const Vs = (t, e) => {\n    const n = Rn.createTransformer(e),\n      s = En(t),\n      i = En(e);\n    return s.indexes.var.length === i.indexes.var.length && s.indexes.color.length === i.indexes.color.length && s.indexes.number.length >= i.indexes.number.length ? Ts.has(t) && !i.values.length || Ts.has(e) && !s.values.length ? function (t, e) {\n      return Ts.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t;\n    }(t, e) : ye(Es(function (t, e) {\n      var n;\n      const s = [],\n        i = {\n          color: 0,\n          var: 0,\n          number: 0\n        };\n      for (let o = 0; o < e.values.length; o++) {\n        const r = e.types[o],\n          a = t.indexes[r][i[r]],\n          l = null !== (n = t.values[a]) && void 0 !== n ? n : 0;\n        s[o] = l, i[r]++;\n      }\n      return s;\n    }(s, i), i.values), n) : Ss(t, e);\n  };\n  function Ms(t, e, n) {\n    if (\"number\" == typeof t && \"number\" == typeof e && \"number\" == typeof n) return gs(t, e, n);\n    return As(t)(t, e);\n  }\n  function Rs(t, e) {\n    let _ref46 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref46$clamp = _ref46.clamp,\n      n = _ref46$clamp === void 0 ? !0 : _ref46$clamp,\n      s = _ref46.ease,\n      i = _ref46.mixer;\n    const o = t.length;\n    if (Ze(o === e.length), 1 === o) return () => e[0];\n    if (2 === o && t[0] === t[1]) return () => e[1];\n    t[0] > t[o - 1] && (t = [...t].reverse(), e = [...e].reverse());\n    const r = function (t, e, n) {\n        const s = [],\n          i = n || Ms,\n          o = t.length - 1;\n        for (let n = 0; n < o; n++) {\n          let o = i(t[n], t[n + 1]);\n          if (e) {\n            const t = Array.isArray(e) ? e[n] || se : e;\n            o = ye(t, o);\n          }\n          s.push(o);\n        }\n        return s;\n      }(e, s, i),\n      a = r.length,\n      l = e => {\n        let n = 0;\n        if (a > 1) for (; n < t.length - 2 && !(e < t[n + 1]); n++);\n        const s = fs(t[n], t[n + 1], e);\n        return r[n](s);\n      };\n    return n ? e => l(ct(t[0], t[o - 1], e)) : l;\n  }\n  function Ds(t, e) {\n    const n = t[t.length - 1];\n    for (let s = 1; s <= e; s++) {\n      const i = fs(0, e, s);\n      t.push(gs(n, 1, i));\n    }\n  }\n  function ks(t) {\n    const e = [0];\n    return Ds(e, t.length - 1), e;\n  }\n  function Ls(_ref47) {\n    let _ref47$duration = _ref47.duration,\n      t = _ref47$duration === void 0 ? 300 : _ref47$duration,\n      e = _ref47.keyframes,\n      n = _ref47.times,\n      _ref47$ease = _ref47.ease,\n      s = _ref47$ease === void 0 ? \"easeInOut\" : _ref47$ease;\n    const i = ss(s) ? s.map(ps) : ps(s),\n      o = {\n        done: !1,\n        value: e[0]\n      },\n      r = Rs(function (t, e) {\n        return t.map(t => t * e);\n      }(n && n.length === e.length ? n : ks(e), t), e, {\n        ease: Array.isArray(i) ? i : (a = e, l = i, a.map(() => l || ns).splice(0, a.length - 1))\n      });\n    var a, l;\n    return {\n      calculatedDuration: t,\n      next: e => (o.value = r(e), o.done = e >= t, o)\n    };\n  }\n  function Bs(t) {\n    let e = 0;\n    let n = t.next(e);\n    for (; !n.done && e < 2e4;) e += 50, n = t.next(e);\n    return e >= 2e4 ? 1 / 0 : e;\n  }\n  const Fs = t => {\n      const e = _ref48 => {\n        let e = _ref48.timestamp;\n        return t(e);\n      };\n      return {\n        start: () => ie.update(e, !0),\n        stop: () => oe(e),\n        now: () => re.isProcessing ? re.timestamp : Ge.now()\n      };\n    },\n    js = {\n      decay: Zn,\n      inertia: Zn,\n      tween: Ls,\n      keyframes: Ls,\n      spring: qn\n    },\n    Os = t => t / 100;\n  class Is extends zn {\n    constructor(_ref49) {\n      let _ref49$KeyframeResolv = _ref49.KeyframeResolver,\n        t = _ref49$KeyframeResolv === void 0 ? yn : _ref49$KeyframeResolv,\n        e = _objectWithoutProperties(_ref49, _excluded6);\n      super(e), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = \"running\", this.state = \"idle\", this.stop = () => {\n        if (this.resolver.cancel(), this.isStopped = !0, \"idle\" === this.state) return;\n        this.teardown();\n        const t = this.options.onStop;\n        t && t();\n      };\n      const _this$options2 = this.options,\n        n = _this$options2.name,\n        s = _this$options2.motionValue,\n        i = _this$options2.keyframes,\n        o = (t, e) => this.onKeyframesResolved(t, e);\n      n && s && s.owner ? this.resolver = s.owner.resolveKeyframes(i, o, n, s) : this.resolver = new t(i, o, n, s), this.resolver.scheduleResolve();\n    }\n    initPlayback(t) {\n      const _this$options3 = this.options,\n        _this$options3$type = _this$options3.type,\n        e = _this$options3$type === void 0 ? \"keyframes\" : _this$options3$type,\n        _this$options3$repeat = _this$options3.repeat,\n        n = _this$options3$repeat === void 0 ? 0 : _this$options3$repeat,\n        _this$options3$repeat2 = _this$options3.repeatDelay,\n        s = _this$options3$repeat2 === void 0 ? 0 : _this$options3$repeat2,\n        i = _this$options3.repeatType,\n        _this$options3$veloci = _this$options3.velocity,\n        o = _this$options3$veloci === void 0 ? 0 : _this$options3$veloci,\n        r = js[e] || Ls;\n      let a, l;\n      r !== Ls && \"number\" != typeof t[0] && (a = ye(Os, Ms(t[0], t[1])), t = [0, 100]);\n      const u = r(_objectSpread(_objectSpread({}, this.options), {}, {\n        keyframes: t\n      }));\n      \"mirror\" === i && (l = r(_objectSpread(_objectSpread({}, this.options), {}, {\n        keyframes: [...t].reverse(),\n        velocity: -o\n      }))), null === u.calculatedDuration && (u.calculatedDuration = Bs(u));\n      const c = u.calculatedDuration,\n        h = c + s;\n      return {\n        generator: u,\n        mirroredGenerator: l,\n        mapPercentToKeyframes: a,\n        calculatedDuration: c,\n        resolvedDuration: h,\n        totalDuration: h * (n + 1) - s\n      };\n    }\n    onPostResolved() {\n      const _this$options$autopla = this.options.autoplay,\n        t = _this$options$autopla === void 0 ? !0 : _this$options$autopla;\n      this.play(), \"paused\" !== this.pendingPlayState && t ? this.state = this.pendingPlayState : this.pause();\n    }\n    tick(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      const n = this.resolved;\n      if (!n) {\n        const t = this.options.keyframes;\n        return {\n          done: !0,\n          value: t[t.length - 1]\n        };\n      }\n      const s = n.finalKeyframe,\n        i = n.generator,\n        o = n.mirroredGenerator,\n        r = n.mapPercentToKeyframes,\n        a = n.keyframes,\n        l = n.calculatedDuration,\n        u = n.totalDuration,\n        c = n.resolvedDuration;\n      if (null === this.startTime) return i.next(0);\n      const _this$options4 = this.options,\n        h = _this$options4.delay,\n        d = _this$options4.repeat,\n        m = _this$options4.repeatType,\n        p = _this$options4.repeatDelay,\n        f = _this$options4.onUpdate;\n      this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), e ? this.currentTime = t : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;\n      const g = this.currentTime - h * (this.speed >= 0 ? 1 : -1),\n        y = this.speed >= 0 ? g < 0 : g > u;\n      this.currentTime = Math.max(g, 0), \"finished\" === this.state && null === this.holdTime && (this.currentTime = u);\n      let v = this.currentTime,\n        x = i;\n      if (d) {\n        const t = Math.min(this.currentTime, u) / c;\n        let e = Math.floor(t),\n          n = t % 1;\n        !n && t >= 1 && (n = 1), 1 === n && e--, e = Math.min(e, d + 1);\n        Boolean(e % 2) && (\"reverse\" === m ? (n = 1 - n, p && (n -= p / c)) : \"mirror\" === m && (x = o)), v = ct(0, 1, n) * c;\n      }\n      const P = y ? {\n        done: !1,\n        value: a[0]\n      } : x.next(v);\n      r && (P.value = r(P.value));\n      let w = P.done;\n      y || null === l || (w = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);\n      const T = null === this.holdTime && (\"finished\" === this.state || \"running\" === this.state && w);\n      return T && void 0 !== s && (P.value = Ye(a, this.options, s)), f && f(P.value), T && this.finish(), P;\n    }\n    get duration() {\n      const t = this.resolved;\n      return t ? Oe(t.calculatedDuration) : 0;\n    }\n    get time() {\n      return Oe(this.currentTime);\n    }\n    set time(t) {\n      t = je(t), this.currentTime = t, null !== this.holdTime || 0 === this.speed ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);\n    }\n    get speed() {\n      return this.playbackSpeed;\n    }\n    set speed(t) {\n      const e = this.playbackSpeed !== t;\n      this.playbackSpeed = t, e && (this.time = Oe(this.currentTime));\n    }\n    play() {\n      if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) return void (this.pendingPlayState = \"running\");\n      if (this.isStopped) return;\n      const _this$options5 = this.options,\n        _this$options5$driver = _this$options5.driver,\n        t = _this$options5$driver === void 0 ? Fs : _this$options5$driver,\n        e = _this$options5.onPlay;\n      this.driver || (this.driver = t(t => this.tick(t))), e && e();\n      const n = this.driver.now();\n      null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime && \"finished\" !== this.state || (this.startTime = n), \"finished\" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = \"running\", this.driver.start();\n    }\n    pause() {\n      var t;\n      this._resolved ? (this.state = \"paused\", this.holdTime = null !== (t = this.currentTime) && void 0 !== t ? t : 0) : this.pendingPlayState = \"paused\";\n    }\n    complete() {\n      \"running\" !== this.state && this.play(), this.pendingPlayState = this.state = \"finished\", this.holdTime = null;\n    }\n    finish() {\n      this.teardown(), this.state = \"finished\";\n      const t = this.options.onComplete;\n      t && t();\n    }\n    cancel() {\n      null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();\n    }\n    teardown() {\n      this.state = \"idle\", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();\n    }\n    stopDriver() {\n      this.driver && (this.driver.stop(), this.driver = void 0);\n    }\n    sample(t) {\n      return this.startTime = 0, this.tick(t, !0);\n    }\n  }\n  function Us(t) {\n    return new Is(t);\n  }\n  const Ws = t => Array.isArray(t) && \"number\" == typeof t[0];\n  function Ns(t) {\n    return Boolean(!t || \"string\" == typeof t && t in Hs || Ws(t) || Array.isArray(t) && t.every(Ns));\n  }\n  const zs = _ref50 => {\n      let _ref51 = _slicedToArray(_ref50, 4),\n        t = _ref51[0],\n        e = _ref51[1],\n        n = _ref51[2],\n        s = _ref51[3];\n      return `cubic-bezier(${t}, ${e}, ${n}, ${s})`;\n    },\n    Hs = {\n      linear: \"linear\",\n      ease: \"ease\",\n      easeIn: \"ease-in\",\n      easeOut: \"ease-out\",\n      easeInOut: \"ease-in-out\",\n      circIn: zs([0, .65, .55, 1]),\n      circOut: zs([.55, 0, 1, .45]),\n      backIn: zs([.31, .01, .66, -.59]),\n      backOut: zs([.33, 1.53, .69, .99])\n    };\n  function $s(t) {\n    return Ys(t) || Hs.easeOut;\n  }\n  function Ys(t) {\n    return t ? Ws(t) ? zs(t) : Array.isArray(t) ? t.map($s) : Hs[t] : void 0;\n  }\n  function Xs(t, e, n) {\n    let _ref52 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref52$delay = _ref52.delay,\n      s = _ref52$delay === void 0 ? 0 : _ref52$delay,\n      _ref52$duration = _ref52.duration,\n      i = _ref52$duration === void 0 ? 300 : _ref52$duration,\n      _ref52$repeat = _ref52.repeat,\n      o = _ref52$repeat === void 0 ? 0 : _ref52$repeat,\n      _ref52$repeatType = _ref52.repeatType,\n      r = _ref52$repeatType === void 0 ? \"loop\" : _ref52$repeatType,\n      a = _ref52.ease,\n      l = _ref52.times;\n    const u = {\n      [e]: n\n    };\n    l && (u.offset = l);\n    const c = Ys(a);\n    return Array.isArray(c) && (u.easing = c), t.animate(u, {\n      delay: s,\n      duration: i,\n      easing: Array.isArray(c) ? \"linear\" : c,\n      fill: \"both\",\n      iterations: o + 1,\n      direction: \"reverse\" === r ? \"alternate\" : \"normal\"\n    });\n  }\n  const Ks = Wn(() => Object.hasOwnProperty.call(Element.prototype, \"animate\")),\n    Gs = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\"]);\n  class _s extends zn {\n    constructor(t) {\n      super(t);\n      const _this$options6 = this.options,\n        e = _this$options6.name,\n        n = _this$options6.motionValue,\n        s = _this$options6.keyframes;\n      this.resolver = new Un(s, (t, e) => this.onKeyframesResolved(t, e), e, n), this.resolver.scheduleResolve();\n    }\n    initPlayback(t, e) {\n      var n;\n      let _this$options7 = this.options,\n        _this$options7$durati = _this$options7.duration,\n        s = _this$options7$durati === void 0 ? 300 : _this$options7$durati,\n        i = _this$options7.times,\n        o = _this$options7.ease,\n        r = _this$options7.type,\n        a = _this$options7.motionValue,\n        l = _this$options7.name;\n      if (!(null === (n = a.owner) || void 0 === n ? void 0 : n.current)) return !1;\n      if (\"spring\" === (u = this.options).type || \"backgroundColor\" === u.name || !Ns(u.ease)) {\n        const _this$options8 = this.options,\n          e = _this$options8.onComplete,\n          n = _this$options8.onUpdate,\n          a = _this$options8.motionValue,\n          l = _objectWithoutProperties(_this$options8, _excluded7),\n          u = function (t, e) {\n            const n = new Is(_objectSpread(_objectSpread({}, e), {}, {\n              keyframes: t,\n              repeat: 0,\n              delay: 0,\n              isGenerator: !0\n            }));\n            let s = {\n              done: !1,\n              value: t[0]\n            };\n            const i = [];\n            let o = 0;\n            for (; !s.done && o < 2e4;) s = n.sample(o), i.push(s.value), o += 10;\n            return {\n              times: void 0,\n              keyframes: i,\n              duration: o - 10,\n              ease: \"linear\"\n            };\n          }(t, l);\n        1 === (t = u.keyframes).length && (t[1] = t[0]), s = u.duration, i = u.times, o = u.ease, r = \"keyframes\";\n      }\n      var u;\n      const c = Xs(a.owner.current, l, t, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: s,\n        times: i,\n        ease: o\n      }));\n      return c.startTime = Ge.now(), this.pendingTimeline ? (c.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : c.onfinish = () => {\n        const n = this.options.onComplete;\n        a.set(Ye(t, this.options, e)), n && n(), this.cancel(), this.resolveFinishedPromise();\n      }, {\n        animation: c,\n        duration: s,\n        times: i,\n        type: r,\n        ease: o,\n        keyframes: t\n      };\n    }\n    get duration() {\n      const t = this.resolved;\n      if (!t) return 0;\n      const e = t.duration;\n      return Oe(e);\n    }\n    get time() {\n      const t = this.resolved;\n      if (!t) return 0;\n      const e = t.animation;\n      return Oe(e.currentTime || 0);\n    }\n    set time(t) {\n      const e = this.resolved;\n      if (!e) return;\n      const n = e.animation;\n      n.currentTime = je(t);\n    }\n    get speed() {\n      const t = this.resolved;\n      if (!t) return 1;\n      const e = t.animation;\n      return e.playbackRate;\n    }\n    set speed(t) {\n      const e = this.resolved;\n      if (!e) return;\n      const n = e.animation;\n      n.playbackRate = t;\n    }\n    get state() {\n      const t = this.resolved;\n      if (!t) return \"idle\";\n      const e = t.animation;\n      return e.playState;\n    }\n    attachTimeline(t) {\n      if (this._resolved) {\n        const e = this.resolved;\n        if (!e) return se;\n        const n = e.animation;\n        n.timeline = t, n.onfinish = null;\n      } else this.pendingTimeline = t;\n      return se;\n    }\n    play() {\n      if (this.isStopped) return;\n      const t = this.resolved;\n      if (!t) return;\n      const e = t.animation;\n      \"finished\" === e.playState && this.updateFinishedPromise(), e.play();\n    }\n    pause() {\n      const t = this.resolved;\n      if (!t) return;\n      const e = t.animation;\n      e.pause();\n    }\n    stop() {\n      if (this.resolver.cancel(), this.isStopped = !0, \"idle\" === this.state) return;\n      const t = this.resolved;\n      if (!t) return;\n      const e = t.animation,\n        n = t.keyframes,\n        s = t.duration,\n        i = t.type,\n        o = t.ease,\n        r = t.times;\n      if (\"idle\" !== e.playState && \"finished\" !== e.playState) {\n        if (this.time) {\n          const _this$options9 = this.options,\n            t = _this$options9.motionValue,\n            e = _this$options9.onUpdate,\n            a = _this$options9.onComplete,\n            l = _objectWithoutProperties(_this$options9, _excluded8),\n            u = new Is(_objectSpread(_objectSpread({}, l), {}, {\n              keyframes: n,\n              duration: s,\n              type: i,\n              ease: o,\n              times: r,\n              isGenerator: !0\n            })),\n            c = je(this.time);\n          t.setWithVelocity(u.sample(c - 10).value, u.sample(c).value, 10);\n        }\n        this.cancel();\n      }\n    }\n    complete() {\n      const t = this.resolved;\n      t && t.animation.finish();\n    }\n    cancel() {\n      const t = this.resolved;\n      t && t.animation.cancel();\n    }\n    static supports(t) {\n      const e = t.motionValue,\n        n = t.name,\n        s = t.repeatDelay,\n        i = t.repeatType,\n        o = t.damping,\n        r = t.type;\n      return Ks() && n && Gs.has(n) && e && e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate && !s && \"mirror\" !== i && 0 !== o && \"inertia\" !== r;\n    }\n  }\n  const qs = function (t, e, n) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let i = arguments.length > 4 ? arguments[4] : undefined;\n    let o = arguments.length > 5 ? arguments[5] : undefined;\n    return r => {\n      const a = ze(s, t) || {},\n        l = a.delay || s.delay || 0;\n      let _s$elapsed = s.elapsed,\n        u = _s$elapsed === void 0 ? 0 : _s$elapsed;\n      u -= je(l);\n      let c = _objectSpread(_objectSpread({\n        keyframes: Array.isArray(n) ? n : [null, n],\n        ease: \"easeOut\",\n        velocity: e.getVelocity()\n      }, a), {}, {\n        delay: -u,\n        onUpdate: t => {\n          e.set(t), a.onUpdate && a.onUpdate(t);\n        },\n        onComplete: () => {\n          r(), a.onComplete && a.onComplete();\n        },\n        name: t,\n        motionValue: e,\n        element: o ? void 0 : i\n      });\n      (function (_ref53) {\n        let t = _ref53.when,\n          e = _ref53.delay,\n          n = _ref53.delayChildren,\n          s = _ref53.staggerChildren,\n          i = _ref53.staggerDirection,\n          o = _ref53.repeat,\n          r = _ref53.repeatType,\n          a = _ref53.repeatDelay,\n          l = _ref53.from,\n          u = _ref53.elapsed,\n          c = _objectWithoutProperties(_ref53, _excluded9);\n        return !!Object.keys(c).length;\n      })(a) || (c = _objectSpread(_objectSpread({}, c), Ne(t, c))), c.duration && (c.duration = je(c.duration)), c.repeatDelay && (c.repeatDelay = je(c.repeatDelay)), void 0 !== c.from && (c.keyframes[0] = c.from);\n      let h = !1;\n      if ((!1 === c.type || 0 === c.duration && !c.repeatDelay) && (c.duration = 0, 0 === c.delay && (h = !0)), (He.current || T.skipAnimations) && (h = !0, c.duration = 0, c.delay = 0), h && !o && void 0 !== e.get()) {\n        const t = Ye(c.keyframes, a);\n        if (void 0 !== t) return void ie.update(() => {\n          c.onUpdate(t), c.onComplete();\n        });\n      }\n      return !o && _s.supports(c) ? new _s(c) : new Is(c);\n    };\n  };\n  function Zs(t) {\n    return Boolean(tt(t) && t.add);\n  }\n  function Js(t, e) {\n    -1 === t.indexOf(e) && t.push(e);\n  }\n  function Qs(t, e) {\n    const n = t.indexOf(e);\n    n > -1 && t.splice(n, 1);\n  }\n  class ti {\n    constructor() {\n      this.subscriptions = [];\n    }\n    add(t) {\n      return Js(this.subscriptions, t), () => Qs(this.subscriptions, t);\n    }\n    notify(t, e, n) {\n      const s = this.subscriptions.length;\n      if (s) if (1 === s) this.subscriptions[0](t, e, n);else for (let i = 0; i < s; i++) {\n        const s = this.subscriptions[i];\n        s && s(t, e, n);\n      }\n    }\n    getSize() {\n      return this.subscriptions.length;\n    }\n    clear() {\n      this.subscriptions.length = 0;\n    }\n  }\n  const ei = {\n    current: void 0\n  };\n  class ni {\n    constructor(t) {\n      var _this = this;\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var n;\n      this.version = \"11.2.0\", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = function (t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n        const n = Ge.now();\n        _this.updatedAt !== n && _this.setPrevFrameValue(), _this.prev = _this.current, _this.setCurrent(t), _this.current !== _this.prev && _this.events.change && _this.events.change.notify(_this.current), e && _this.events.renderRequest && _this.events.renderRequest.notify(_this.current);\n      }, this.hasAnimated = !1, this.setCurrent(t), this.canTrackVelocity = (n = this.current, !isNaN(parseFloat(n))), this.owner = e.owner;\n    }\n    setCurrent(t) {\n      this.current = t, this.updatedAt = Ge.now();\n    }\n    setPrevFrameValue() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.current;\n      this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;\n    }\n    onChange(t) {\n      return this.on(\"change\", t);\n    }\n    on(t, e) {\n      this.events[t] || (this.events[t] = new ti());\n      const n = this.events[t].add(e);\n      return \"change\" === t ? () => {\n        n(), ie.read(() => {\n          this.events.change.getSize() || this.stop();\n        });\n      } : n;\n    }\n    clearListeners() {\n      for (const t in this.events) this.events[t].clear();\n    }\n    attach(t, e) {\n      this.passiveEffect = t, this.stopPassiveEffect = e;\n    }\n    set(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n      e && this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t, e);\n    }\n    setWithVelocity(t, e, n) {\n      this.set(e), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - n;\n    }\n    jump(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n      this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, e && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n    }\n    get() {\n      return ei.current && ei.current.push(this), this.current;\n    }\n    getPrevious() {\n      return this.prev;\n    }\n    getVelocity() {\n      const t = Ge.now();\n      if (!this.canTrackVelocity || void 0 === this.prevFrameValue || t - this.updatedAt > 30) return 0;\n      const e = Math.min(this.updatedAt - this.prevUpdatedAt, 30);\n      return Hn(parseFloat(this.current) - parseFloat(this.prevFrameValue), e);\n    }\n    start(t) {\n      return this.stop(), new Promise(e => {\n        this.hasAnimated = !0, this.animation = t(e), this.events.animationStart && this.events.animationStart.notify();\n      }).then(() => {\n        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();\n      });\n    }\n    stop() {\n      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();\n    }\n    isAnimating() {\n      return !!this.animation;\n    }\n    clearAnimation() {\n      delete this.animation;\n    }\n    destroy() {\n      this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n    }\n  }\n  function si(t, e) {\n    return new ni(t, e);\n  }\n  function ii(t, e, n) {\n    t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, si(n));\n  }\n  function oi(t, e) {\n    const n = Fe(t, e);\n    let _ref54 = n || {},\n      _ref54$transitionEnd = _ref54.transitionEnd,\n      s = _ref54$transitionEnd === void 0 ? {} : _ref54$transitionEnd,\n      _ref54$transition = _ref54.transition,\n      i = _ref54$transition === void 0 ? {} : _ref54$transition,\n      o = _objectWithoutProperties(_ref54, _excluded10);\n    o = _objectSpread(_objectSpread({}, o), s);\n    for (const e in o) {\n      ii(t, e, (r = o[e], Qt(r) ? r[r.length - 1] || 0 : r));\n    }\n    var r;\n  }\n  function ri(_ref55, n) {\n    let t = _ref55.protectedKeys,\n      e = _ref55.needsAnimating;\n    const s = t.hasOwnProperty(n) && !0 !== e[n];\n    return e[n] = !1, s;\n  }\n  function ai(t, e) {\n    let _ref56 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref56$delay = _ref56.delay,\n      n = _ref56$delay === void 0 ? 0 : _ref56$delay,\n      s = _ref56.transitionOverride,\n      i = _ref56.type;\n    var o;\n    let _e$transition = e.transition,\n      r = _e$transition === void 0 ? t.getDefaultTransition() : _e$transition,\n      a = e.transitionEnd,\n      l = _objectWithoutProperties(e, _excluded11);\n    const u = t.getValue(\"willChange\");\n    s && (r = s);\n    const c = [],\n      h = i && t.animationState && t.animationState.getState()[i];\n    for (const e in l) {\n      const s = t.getValue(e, null !== (o = t.latestValues[e]) && void 0 !== o ? o : null),\n        i = l[e];\n      if (void 0 === i || h && ri(h, e)) continue;\n      const a = _objectSpread({\n        delay: n,\n        elapsed: 0\n      }, ze(r || {}, e));\n      let d = !1;\n      if (window.HandoffAppearAnimations) {\n        const n = t.getProps()[w];\n        if (n) {\n          const t = window.HandoffAppearAnimations(n, e);\n          null !== t && (a.elapsed = t, d = !0);\n        }\n      }\n      s.start(qs(e, s, i, t.shouldReduceMotion && J.has(e) ? {\n        type: !1\n      } : a, t, d));\n      const m = s.animation;\n      m && (Zs(u) && (u.add(e), m.then(() => u.remove(e))), c.push(m));\n    }\n    return a && Promise.all(c).then(() => {\n      ie.update(() => {\n        a && oi(t, a);\n      });\n    }), c;\n  }\n  function li(t, e) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var s;\n    const i = Fe(t, e, \"exit\" === n.type ? null === (s = t.presenceContext) || void 0 === s ? void 0 : s.custom : void 0);\n    let _ref57 = i || {},\n      _ref57$transition = _ref57.transition,\n      o = _ref57$transition === void 0 ? t.getDefaultTransition() || {} : _ref57$transition;\n    n.transitionOverride && (o = n.transitionOverride);\n    const r = i ? () => Promise.all(ai(t, i, n)) : () => Promise.resolve(),\n      a = t.variantChildren && t.variantChildren.size ? function () {\n        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        const _o3 = o,\n          _o3$delayChildren = _o3.delayChildren,\n          i = _o3$delayChildren === void 0 ? 0 : _o3$delayChildren,\n          r = _o3.staggerChildren,\n          a = _o3.staggerDirection;\n        return function (t, e) {\n          let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n          let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n          let o = arguments.length > 5 ? arguments[5] : undefined;\n          const r = [],\n            a = (t.variantChildren.size - 1) * s,\n            l = 1 === i ? function () {\n              let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n              return t * s;\n            } : function () {\n              let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n              return a - t * s;\n            };\n          return Array.from(t.variantChildren).sort(ui).forEach((t, s) => {\n            t.notify(\"AnimationStart\", e), r.push(li(t, e, _objectSpread(_objectSpread({}, o), {}, {\n              delay: n + l(s)\n            })).then(() => t.notify(\"AnimationComplete\", e)));\n          }), Promise.all(r);\n        }(t, e, i + s, r, a, n);\n      } : () => Promise.resolve(),\n      _o2 = o,\n      l = _o2.when;\n    if (l) {\n      const _ref58 = \"beforeChildren\" === l ? [r, a] : [a, r],\n        _ref59 = _slicedToArray(_ref58, 2),\n        t = _ref59[0],\n        e = _ref59[1];\n      return t().then(() => e());\n    }\n    return Promise.all([r(), a(n.delay)]);\n  }\n  function ui(t, e) {\n    return t.sortNodePosition(e);\n  }\n  function ci(t, e) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let s;\n    if (t.notify(\"AnimationStart\", e), Array.isArray(e)) {\n      const i = e.map(e => li(t, e, n));\n      s = Promise.all(i);\n    } else if (\"string\" == typeof e) s = li(t, e, n);else {\n      const i = \"function\" == typeof e ? Fe(t, e, n.custom) : e;\n      s = Promise.all(ai(t, i, n));\n    }\n    return s.then(() => {\n      ie.postRender(() => {\n        t.notify(\"AnimationComplete\", e);\n      });\n    });\n  }\n  const hi = [...k].reverse(),\n    di = k.length;\n  function mi(t) {\n    let e = function (t) {\n      return e => Promise.all(e.map(_ref60 => {\n        let e = _ref60.animation,\n          n = _ref60.options;\n        return ci(t, e, n);\n      }));\n    }(t);\n    const n = {\n      animate: fi(!0),\n      whileInView: fi(),\n      whileHover: fi(),\n      whileTap: fi(),\n      whileDrag: fi(),\n      whileFocus: fi(),\n      exit: fi()\n    };\n    let s = !0;\n    const i = e => (n, s) => {\n      var i;\n      const o = Fe(t, s, \"exit\" === e ? null === (i = t.presenceContext) || void 0 === i ? void 0 : i.custom : void 0);\n      if (o) {\n        const t = o.transition,\n          e = o.transitionEnd,\n          s = _objectWithoutProperties(o, _excluded12);\n        n = _objectSpread(_objectSpread(_objectSpread({}, n), s), e);\n      }\n      return n;\n    };\n    function o(o) {\n      const r = t.getProps(),\n        a = t.getVariantContext(!0) || {},\n        l = [],\n        u = new Set();\n      let c = {},\n        h = 1 / 0;\n      for (let e = 0; e < di; e++) {\n        const d = hi[e],\n          m = n[d],\n          p = void 0 !== r[d] ? r[d] : a[d],\n          f = R(p),\n          g = d === o ? m.isActive : null;\n        !1 === g && (h = e);\n        let y = p === a[d] && p !== r[d] && f;\n        if (y && s && t.manuallyAnimateOnMount && (y = !1), m.protectedKeys = _objectSpread({}, c), !m.isActive && null === g || !p && !m.prevProp || D(p) || \"boolean\" == typeof p) continue;\n        let v = pi(m.prevProp, p) || d === o && m.isActive && !y && f || e > h && f,\n          x = !1;\n        const P = Array.isArray(p) ? p : [p];\n        let w = P.reduce(i(d), {});\n        !1 === g && (w = {});\n        const _m$prevResolvedValues = m.prevResolvedValues,\n          T = _m$prevResolvedValues === void 0 ? {} : _m$prevResolvedValues,\n          S = _objectSpread(_objectSpread({}, T), w),\n          b = e => {\n            v = !0, u.has(e) && (x = !0, u.delete(e)), m.needsAnimating[e] = !0;\n            const n = t.getValue(e);\n            n && (n.liveStyle = !1);\n          };\n        for (const t in S) {\n          const e = w[t],\n            n = T[t];\n          if (c.hasOwnProperty(t)) continue;\n          let s = !1;\n          s = Qt(e) && Qt(n) ? !Be(e, n) : e !== n, s ? null != e ? b(t) : u.add(t) : void 0 !== e && u.has(t) ? b(t) : m.protectedKeys[t] = !0;\n        }\n        m.prevProp = p, m.prevResolvedValues = w, m.isActive && (c = _objectSpread(_objectSpread({}, c), w)), s && t.blockInitialAnimation && (v = !1), !v || y && !x || l.push(...P.map(t => ({\n          animation: t,\n          options: {\n            type: d\n          }\n        })));\n      }\n      if (u.size) {\n        const e = {};\n        u.forEach(n => {\n          const s = t.getBaseTarget(n),\n            i = t.getValue(n);\n          i && (i.liveStyle = !0), e[n] = null != s ? s : null;\n        }), l.push({\n          animation: e\n        });\n      }\n      let d = Boolean(l.length);\n      return !s || !1 !== r.initial && r.initial !== r.animate || t.manuallyAnimateOnMount || (d = !1), s = !1, d ? e(l) : Promise.resolve();\n    }\n    return {\n      animateChanges: o,\n      setActive: function (e, s) {\n        var i;\n        if (n[e].isActive === s) return Promise.resolve();\n        null === (i = t.variantChildren) || void 0 === i || i.forEach(t => {\n          var n;\n          return null === (n = t.animationState) || void 0 === n ? void 0 : n.setActive(e, s);\n        }), n[e].isActive = s;\n        const r = o(e);\n        for (const t in n) n[t].protectedKeys = {};\n        return r;\n      },\n      setAnimateFunction: function (n) {\n        e = n(t);\n      },\n      getState: () => n\n    };\n  }\n  function pi(t, e) {\n    return \"string\" == typeof e ? e !== t : !!Array.isArray(e) && !Be(e, t);\n  }\n  function fi() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    return {\n      isActive: t,\n      protectedKeys: {},\n      needsAnimating: {},\n      prevResolvedValues: {}\n    };\n  }\n  let gi = 0;\n  const yi = {\n      animation: {\n        Feature: class extends Se {\n          constructor(t) {\n            super(t), t.animationState || (t.animationState = mi(t));\n          }\n          updateAnimationControlsSubscription() {\n            const _this$node$getProps7 = this.node.getProps(),\n              t = _this$node$getProps7.animate;\n            this.unmount(), D(t) && (this.unmount = t.subscribe(this.node));\n          }\n          mount() {\n            this.updateAnimationControlsSubscription();\n          }\n          update() {\n            const _this$node$getProps8 = this.node.getProps(),\n              t = _this$node$getProps8.animate,\n              _ref61 = this.node.prevProps || {},\n              e = _ref61.animate;\n            t !== e && this.updateAnimationControlsSubscription();\n          }\n          unmount() {}\n        }\n      },\n      exit: {\n        Feature: class extends Se {\n          constructor() {\n            super(...arguments), this.id = gi++;\n          }\n          update() {\n            if (!this.node.presenceContext) return;\n            const _this$node$presenceCo = this.node.presenceContext,\n              t = _this$node$presenceCo.isPresent,\n              e = _this$node$presenceCo.onExitComplete,\n              _ref62 = this.node.prevPresenceContext || {},\n              n = _ref62.isPresent;\n            if (!this.node.animationState || t === n) return;\n            const s = this.node.animationState.setActive(\"exit\", !t);\n            e && !t && s.then(() => e(this.id));\n          }\n          mount() {\n            const _ref63 = this.node.presenceContext || {},\n              t = _ref63.register;\n            t && (this.unmount = t(this.id));\n          }\n          unmount() {}\n        }\n      }\n    },\n    vi = (t, e) => Math.abs(t - e);\n  function xi(t, e) {\n    const n = vi(t.x, e.x),\n      s = vi(t.y, e.y);\n    return Math.sqrt(n ** 2 + s ** 2);\n  }\n  class Pi {\n    constructor(t, e) {\n      let _ref64 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        n = _ref64.transformPagePoint,\n        s = _ref64.contextWindow,\n        _ref64$dragSnapToOrig = _ref64.dragSnapToOrigin,\n        i = _ref64$dragSnapToOrig === void 0 ? !1 : _ref64$dragSnapToOrig;\n      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {\n        if (!this.lastMoveEvent || !this.lastMoveEventInfo) return;\n        const t = Si(this.lastMoveEventInfo, this.history),\n          e = null !== this.startEvent,\n          n = xi(t.offset, {\n            x: 0,\n            y: 0\n          }) >= 3;\n        if (!e && !n) return;\n        const s = t.point,\n          i = re.timestamp;\n        this.history.push(_objectSpread(_objectSpread({}, s), {}, {\n          timestamp: i\n        }));\n        const _this$handlers = this.handlers,\n          o = _this$handlers.onStart,\n          r = _this$handlers.onMove;\n        e || (o && o(this.lastMoveEvent, t), this.startEvent = this.lastMoveEvent), r && r(this.lastMoveEvent, t);\n      }, this.handlePointerMove = (t, e) => {\n        this.lastMoveEvent = t, this.lastMoveEventInfo = wi(e, this.transformPagePoint), ie.update(this.updatePoint, !0);\n      }, this.handlePointerUp = (t, e) => {\n        this.end();\n        const _this$handlers2 = this.handlers,\n          n = _this$handlers2.onEnd,\n          s = _this$handlers2.onSessionEnd,\n          i = _this$handlers2.resumeAnimation;\n        if (this.dragSnapToOrigin && i && i(), !this.lastMoveEvent || !this.lastMoveEventInfo) return;\n        const o = Si(\"pointercancel\" === t.type ? this.lastMoveEventInfo : wi(e, this.transformPagePoint), this.history);\n        this.startEvent && n && n(t, o), s && s(t, o);\n      }, !de(t)) return;\n      this.dragSnapToOrigin = i, this.handlers = e, this.transformPagePoint = n, this.contextWindow = s || window;\n      const o = wi(me(t), this.transformPagePoint),\n        r = o.point,\n        a = re.timestamp;\n      this.history = [_objectSpread(_objectSpread({}, r), {}, {\n        timestamp: a\n      })];\n      const l = e.onSessionStart;\n      l && l(t, Si(o, this.history)), this.removeListeners = ye(fe(this.contextWindow, \"pointermove\", this.handlePointerMove), fe(this.contextWindow, \"pointerup\", this.handlePointerUp), fe(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(t) {\n      this.handlers = t;\n    }\n    end() {\n      this.removeListeners && this.removeListeners(), oe(this.updatePoint);\n    }\n  }\n  function wi(t, e) {\n    return e ? {\n      point: e(t.point)\n    } : t;\n  }\n  function Ti(t, e) {\n    return {\n      x: t.x - e.x,\n      y: t.y - e.y\n    };\n  }\n  function Si(_ref65, e) {\n    let t = _ref65.point;\n    return {\n      point: t,\n      delta: Ti(t, Ai(e)),\n      offset: Ti(t, bi(e)),\n      velocity: Ei(e, .1)\n    };\n  }\n  function bi(t) {\n    return t[0];\n  }\n  function Ai(t) {\n    return t[t.length - 1];\n  }\n  function Ei(t, e) {\n    if (t.length < 2) return {\n      x: 0,\n      y: 0\n    };\n    let n = t.length - 1,\n      s = null;\n    const i = Ai(t);\n    for (; n >= 0 && (s = t[n], !(i.timestamp - s.timestamp > je(e)));) n--;\n    if (!s) return {\n      x: 0,\n      y: 0\n    };\n    const o = Oe(i.timestamp - s.timestamp);\n    if (0 === o) return {\n      x: 0,\n      y: 0\n    };\n    const r = {\n      x: (i.x - s.x) / o,\n      y: (i.y - s.y) / o\n    };\n    return r.x === 1 / 0 && (r.x = 0), r.y === 1 / 0 && (r.y = 0), r;\n  }\n  function Ci(t) {\n    return t.max - t.min;\n  }\n  function Vi(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .01;\n    return Math.abs(t - e) <= n;\n  }\n  function Mi(t, e, n) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n    t.origin = s, t.originPoint = gs(e.min, e.max, t.origin), t.scale = Ci(n) / Ci(e), (Vi(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = gs(n.min, n.max, t.origin) - t.originPoint, (Vi(t.translate) || isNaN(t.translate)) && (t.translate = 0);\n  }\n  function Ri(t, e, n, s) {\n    Mi(t.x, e.x, n.x, s ? s.originX : void 0), Mi(t.y, e.y, n.y, s ? s.originY : void 0);\n  }\n  function Di(t, e, n) {\n    t.min = n.min + e.min, t.max = t.min + Ci(e);\n  }\n  function ki(t, e, n) {\n    t.min = e.min - n.min, t.max = t.min + Ci(e);\n  }\n  function Li(t, e, n) {\n    ki(t.x, e.x, n.x), ki(t.y, e.y, n.y);\n  }\n  function Bi(t, e, n) {\n    return {\n      min: void 0 !== e ? t.min + e : void 0,\n      max: void 0 !== n ? t.max + n - (t.max - t.min) : void 0\n    };\n  }\n  function Fi(t, e) {\n    var _ref66;\n    let n = e.min - t.min,\n      s = e.max - t.max;\n    return e.max - e.min < t.max - t.min && (_ref66 = [s, n], n = _ref66[0], s = _ref66[1], _ref66), {\n      min: n,\n      max: s\n    };\n  }\n  const ji = .35;\n  function Oi(t, e, n) {\n    return {\n      min: Ii(t, e),\n      max: Ii(t, n)\n    };\n  }\n  function Ii(t, e) {\n    return \"number\" == typeof t ? t : t[e] || 0;\n  }\n  const Ui = () => ({\n    x: {\n      min: 0,\n      max: 0\n    },\n    y: {\n      min: 0,\n      max: 0\n    }\n  });\n  function Wi(t) {\n    return [t(\"x\"), t(\"y\")];\n  }\n  function Ni(_ref67) {\n    let t = _ref67.top,\n      e = _ref67.left,\n      n = _ref67.right,\n      s = _ref67.bottom;\n    return {\n      x: {\n        min: e,\n        max: n\n      },\n      y: {\n        min: t,\n        max: s\n      }\n    };\n  }\n  function zi(t) {\n    return void 0 === t || 1 === t;\n  }\n  function Hi(_ref68) {\n    let t = _ref68.scale,\n      e = _ref68.scaleX,\n      n = _ref68.scaleY;\n    return !zi(t) || !zi(e) || !zi(n);\n  }\n  function $i(t) {\n    return Hi(t) || Yi(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;\n  }\n  function Yi(t) {\n    return Xi(t.x) || Xi(t.y);\n  }\n  function Xi(t) {\n    return t && \"0%\" !== t;\n  }\n  function Ki(t, e, n) {\n    return n + e * (t - n);\n  }\n  function Gi(t, e, n, s, i) {\n    return void 0 !== i && (t = Ki(t, i, s)), Ki(t, n, s) + e;\n  }\n  function _i(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let s = arguments.length > 3 ? arguments[3] : undefined;\n    let i = arguments.length > 4 ? arguments[4] : undefined;\n    t.min = Gi(t.min, e, n, s, i), t.max = Gi(t.max, e, n, s, i);\n  }\n  function qi(t, _ref69) {\n    let e = _ref69.x,\n      n = _ref69.y;\n    _i(t.x, e.translate, e.scale, e.originPoint), _i(t.y, n.translate, n.scale, n.originPoint);\n  }\n  function Zi(t) {\n    return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1;\n  }\n  function Ji(t, e) {\n    t.min = t.min + e, t.max = t.max + e;\n  }\n  function Qi(t, e, _ref70) {\n    let _ref71 = _slicedToArray(_ref70, 3),\n      n = _ref71[0],\n      s = _ref71[1],\n      i = _ref71[2];\n    const o = void 0 !== e[i] ? e[i] : .5,\n      r = gs(t.min, t.max, o);\n    _i(t, e[n], e[s], r, e.scale);\n  }\n  const to = [\"x\", \"scaleX\", \"originX\"],\n    eo = [\"y\", \"scaleY\", \"originY\"];\n  function no(t, e) {\n    Qi(t.x, e, to), Qi(t.y, e, eo);\n  }\n  function so(t, e) {\n    return Ni(function (t, e) {\n      if (!e) return t;\n      const n = e({\n          x: t.left,\n          y: t.top\n        }),\n        s = e({\n          x: t.right,\n          y: t.bottom\n        });\n      return {\n        top: n.y,\n        left: n.x,\n        bottom: s.y,\n        right: s.x\n      };\n    }(t.getBoundingClientRect(), e));\n  }\n  const io = _ref72 => {\n      let t = _ref72.current;\n      return t ? t.ownerDocument.defaultView : null;\n    },\n    oo = new WeakMap();\n  class ro {\n    constructor(t) {\n      this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {\n        x: 0,\n        y: 0\n      }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = {\n        x: {\n          min: 0,\n          max: 0\n        },\n        y: {\n          min: 0,\n          max: 0\n        }\n      }, this.visualElement = t;\n    }\n    start(t) {\n      let _ref73 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref73$snapToCursor = _ref73.snapToCursor,\n        e = _ref73$snapToCursor === void 0 ? !1 : _ref73$snapToCursor;\n      const n = this.visualElement.presenceContext;\n      if (n && !1 === n.isPresent) return;\n      const _this$getProps = this.getProps(),\n        s = _this$getProps.dragSnapToOrigin;\n      this.panSession = new Pi(t, {\n        onSessionStart: t => {\n          const _this$getProps2 = this.getProps(),\n            n = _this$getProps2.dragSnapToOrigin;\n          n ? this.pauseAnimation() : this.stopAnimation(), e && this.snapToCursor(me(t, \"page\").point);\n        },\n        onStart: (t, e) => {\n          const _this$getProps3 = this.getProps(),\n            n = _this$getProps3.drag,\n            s = _this$getProps3.dragPropagation,\n            i = _this$getProps3.onDragStart;\n          if (n && !s && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = we(n), !this.openGlobalLock)) return;\n          this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Wi(t => {\n            let e = this.getAxisMotionValue(t).get() || 0;\n            if (wt.test(e)) {\n              const n = this.visualElement.projection;\n              if (n && n.layout) {\n                const s = n.layout.layoutBox[t];\n                if (s) {\n                  e = Ci(s) * (parseFloat(e) / 100);\n                }\n              }\n            }\n            this.originPoint[t] = e;\n          }), i && ie.postRender(() => i(t, e));\n          const o = this.visualElement.animationState;\n          o && o.setActive(\"whileDrag\", !0);\n        },\n        onMove: (t, e) => {\n          const _this$getProps4 = this.getProps(),\n            n = _this$getProps4.dragPropagation,\n            s = _this$getProps4.dragDirectionLock,\n            i = _this$getProps4.onDirectionLock,\n            o = _this$getProps4.onDrag;\n          if (!n && !this.openGlobalLock) return;\n          const r = e.offset;\n          if (s && null === this.currentDirection) return this.currentDirection = function (t) {\n            let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n            let n = null;\n            Math.abs(t.y) > e ? n = \"y\" : Math.abs(t.x) > e && (n = \"x\");\n            return n;\n          }(r), void (null !== this.currentDirection && i && i(this.currentDirection));\n          this.updateAxis(\"x\", e.point, r), this.updateAxis(\"y\", e.point, r), this.visualElement.render(), o && o(t, e);\n        },\n        onSessionEnd: (t, e) => this.stop(t, e),\n        resumeAnimation: () => Wi(t => {\n          var e;\n          return \"paused\" === this.getAnimationState(t) && (null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.play());\n        })\n      }, {\n        transformPagePoint: this.visualElement.getTransformPagePoint(),\n        dragSnapToOrigin: s,\n        contextWindow: io(this.visualElement)\n      });\n    }\n    stop(t, e) {\n      const n = this.isDragging;\n      if (this.cancel(), !n) return;\n      const s = e.velocity;\n      this.startAnimation(s);\n      const _this$getProps5 = this.getProps(),\n        i = _this$getProps5.onDragEnd;\n      i && ie.postRender(() => i(t, e));\n    }\n    cancel() {\n      this.isDragging = !1;\n      const _this$visualElement = this.visualElement,\n        t = _this$visualElement.projection,\n        e = _this$visualElement.animationState;\n      t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;\n      const _this$getProps6 = this.getProps(),\n        n = _this$getProps6.dragPropagation;\n      !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), e && e.setActive(\"whileDrag\", !1);\n    }\n    updateAxis(t, e, n) {\n      const _this$getProps7 = this.getProps(),\n        s = _this$getProps7.drag;\n      if (!n || !ao(t, s, this.currentDirection)) return;\n      const i = this.getAxisMotionValue(t);\n      let o = this.originPoint[t] + n[t];\n      this.constraints && this.constraints[t] && (o = function (t, _ref74, s) {\n        let e = _ref74.min,\n          n = _ref74.max;\n        return void 0 !== e && t < e ? t = s ? gs(e, t, s.min) : Math.max(t, e) : void 0 !== n && t > n && (t = s ? gs(n, t, s.max) : Math.min(t, n)), t;\n      }(o, this.constraints[t], this.elastic[t])), i.set(o);\n    }\n    resolveConstraints() {\n      var t;\n      const _this$getProps8 = this.getProps(),\n        e = _this$getProps8.dragConstraints,\n        n = _this$getProps8.dragElastic,\n        s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (t = this.visualElement.projection) || void 0 === t ? void 0 : t.layout,\n        i = this.constraints;\n      e && V(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!e || !s) && function (t, _ref75) {\n        let e = _ref75.top,\n          n = _ref75.left,\n          s = _ref75.bottom,\n          i = _ref75.right;\n        return {\n          x: Bi(t.x, n, i),\n          y: Bi(t.y, e, s)\n        };\n      }(s.layoutBox, e), this.elastic = function () {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ji;\n        return !1 === t ? t = 0 : !0 === t && (t = ji), {\n          x: Oi(t, \"left\", \"right\"),\n          y: Oi(t, \"top\", \"bottom\")\n        };\n      }(n), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && Wi(t => {\n        !1 !== this.constraints && this.getAxisMotionValue(t) && (this.constraints[t] = function (t, e) {\n          const n = {};\n          return void 0 !== e.min && (n.min = e.min - t.min), void 0 !== e.max && (n.max = e.max - t.min), n;\n        }(s.layoutBox[t], this.constraints[t]));\n      });\n    }\n    resolveRefConstraints() {\n      const _this$getProps9 = this.getProps(),\n        t = _this$getProps9.dragConstraints,\n        e = _this$getProps9.onMeasureDragConstraints;\n      if (!t || !V(t)) return !1;\n      const n = t.current,\n        s = this.visualElement.projection;\n      if (!s || !s.layout) return !1;\n      const i = function (t, e, n) {\n        const s = so(t, n),\n          i = e.scroll;\n        return i && (Ji(s.x, i.offset.x), Ji(s.y, i.offset.y)), s;\n      }(n, s.root, this.visualElement.getTransformPagePoint());\n      let o = function (t, e) {\n        return {\n          x: Fi(t.x, e.x),\n          y: Fi(t.y, e.y)\n        };\n      }(s.layout.layoutBox, i);\n      if (e) {\n        const t = e(function (_ref76) {\n          let t = _ref76.x,\n            e = _ref76.y;\n          return {\n            top: e.min,\n            right: t.max,\n            bottom: e.max,\n            left: t.min\n          };\n        }(o));\n        this.hasMutatedConstraints = !!t, t && (o = Ni(t));\n      }\n      return o;\n    }\n    startAnimation(t) {\n      const _this$getProps10 = this.getProps(),\n        e = _this$getProps10.drag,\n        n = _this$getProps10.dragMomentum,\n        s = _this$getProps10.dragElastic,\n        i = _this$getProps10.dragTransition,\n        o = _this$getProps10.dragSnapToOrigin,\n        r = _this$getProps10.onDragTransitionEnd,\n        a = this.constraints || {},\n        l = Wi(r => {\n          if (!ao(r, e, this.currentDirection)) return;\n          let l = a && a[r] || {};\n          o && (l = {\n            min: 0,\n            max: 0\n          });\n          const u = s ? 200 : 1e6,\n            c = s ? 40 : 1e7,\n            h = _objectSpread(_objectSpread({\n              type: \"inertia\",\n              velocity: n ? t[r] : 0,\n              bounceStiffness: u,\n              bounceDamping: c,\n              timeConstant: 750,\n              restDelta: 1,\n              restSpeed: 10\n            }, i), l);\n          return this.startAxisValueAnimation(r, h);\n        });\n      return Promise.all(l).then(r);\n    }\n    startAxisValueAnimation(t, e) {\n      const n = this.getAxisMotionValue(t);\n      return n.start(qs(t, n, 0, e, this.visualElement));\n    }\n    stopAnimation() {\n      Wi(t => this.getAxisMotionValue(t).stop());\n    }\n    pauseAnimation() {\n      Wi(t => {\n        var e;\n        return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.pause();\n      });\n    }\n    getAnimationState(t) {\n      var e;\n      return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.state;\n    }\n    getAxisMotionValue(t) {\n      const e = \"_drag\" + t.toUpperCase(),\n        n = this.visualElement.getProps(),\n        s = n[e];\n      return s || this.visualElement.getValue(t, (n.initial ? n.initial[t] : void 0) || 0);\n    }\n    snapToCursor(t) {\n      Wi(e => {\n        const _this$getProps11 = this.getProps(),\n          n = _this$getProps11.drag;\n        if (!ao(e, n, this.currentDirection)) return;\n        const s = this.visualElement.projection,\n          i = this.getAxisMotionValue(e);\n        if (s && s.layout) {\n          const _s$layout$layoutBox$e = s.layout.layoutBox[e],\n            n = _s$layout$layoutBox$e.min,\n            o = _s$layout$layoutBox$e.max;\n          i.set(t[e] - gs(n, o, .5));\n        }\n      });\n    }\n    scalePositionWithinConstraints() {\n      if (!this.visualElement.current) return;\n      const _this$getProps12 = this.getProps(),\n        t = _this$getProps12.drag,\n        e = _this$getProps12.dragConstraints,\n        n = this.visualElement.projection;\n      if (!V(e) || !n || !this.constraints) return;\n      this.stopAnimation();\n      const s = {\n        x: 0,\n        y: 0\n      };\n      Wi(t => {\n        const e = this.getAxisMotionValue(t);\n        if (e && !1 !== this.constraints) {\n          const n = e.get();\n          s[t] = function (t, e) {\n            let n = .5;\n            const s = Ci(t),\n              i = Ci(e);\n            return i > s ? n = fs(e.min, e.max - s, t.min) : s > i && (n = fs(t.min, t.max - i, e.min)), ct(0, 1, n);\n          }({\n            min: n,\n            max: n\n          }, this.constraints[t]);\n        }\n      });\n      const _this$visualElement$g = this.visualElement.getProps(),\n        i = _this$visualElement$g.transformTemplate;\n      this.visualElement.current.style.transform = i ? i({}, \"\") : \"none\", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Wi(e => {\n        if (!ao(e, t, null)) return;\n        const n = this.getAxisMotionValue(e),\n          _this$constraints$e = this.constraints[e],\n          i = _this$constraints$e.min,\n          o = _this$constraints$e.max;\n        n.set(gs(i, o, s[e]));\n      });\n    }\n    addListeners() {\n      if (!this.visualElement.current) return;\n      oo.set(this.visualElement, this);\n      const t = fe(this.visualElement.current, \"pointerdown\", t => {\n          const _this$getProps13 = this.getProps(),\n            e = _this$getProps13.drag,\n            _this$getProps13$drag = _this$getProps13.dragListener,\n            n = _this$getProps13$drag === void 0 ? !0 : _this$getProps13$drag;\n          e && n && this.start(t);\n        }),\n        e = () => {\n          const _this$getProps14 = this.getProps(),\n            t = _this$getProps14.dragConstraints;\n          V(t) && (this.constraints = this.resolveRefConstraints());\n        },\n        n = this.visualElement.projection,\n        s = n.addEventListener(\"measure\", e);\n      n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), e();\n      const i = he(window, \"resize\", () => this.scalePositionWithinConstraints()),\n        o = n.addEventListener(\"didUpdate\", _ref77 => {\n          let t = _ref77.delta,\n            e = _ref77.hasLayoutChanged;\n          this.isDragging && e && (Wi(e => {\n            const n = this.getAxisMotionValue(e);\n            n && (this.originPoint[e] += t[e].translate, n.set(n.get() + t[e].translate));\n          }), this.visualElement.render());\n        });\n      return () => {\n        i(), t(), s(), o && o();\n      };\n    }\n    getProps() {\n      const t = this.visualElement.getProps(),\n        _t$drag = t.drag,\n        e = _t$drag === void 0 ? !1 : _t$drag,\n        _t$dragDirectionLock = t.dragDirectionLock,\n        n = _t$dragDirectionLock === void 0 ? !1 : _t$dragDirectionLock,\n        _t$dragPropagation = t.dragPropagation,\n        s = _t$dragPropagation === void 0 ? !1 : _t$dragPropagation,\n        _t$dragConstraints = t.dragConstraints,\n        i = _t$dragConstraints === void 0 ? !1 : _t$dragConstraints,\n        _t$dragElastic = t.dragElastic,\n        o = _t$dragElastic === void 0 ? ji : _t$dragElastic,\n        _t$dragMomentum = t.dragMomentum,\n        r = _t$dragMomentum === void 0 ? !0 : _t$dragMomentum;\n      return _objectSpread(_objectSpread({}, t), {}, {\n        drag: e,\n        dragDirectionLock: n,\n        dragPropagation: s,\n        dragConstraints: i,\n        dragElastic: o,\n        dragMomentum: r\n      });\n    }\n  }\n  function ao(t, e, n) {\n    return !(!0 !== e && e !== t || null !== n && n !== t);\n  }\n  const lo = t => (e, n) => {\n    t && ie.postRender(() => t(e, n));\n  };\n  const uo = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"],\n    co = uo.length,\n    ho = t => \"string\" == typeof t ? parseFloat(t) : t,\n    mo = t => \"number\" == typeof t || Tt.test(t);\n  function po(t, e) {\n    return void 0 !== t[e] ? t[e] : t.borderRadius;\n  }\n  const fo = yo(0, .5, as),\n    go = yo(.5, .95, se);\n  function yo(t, e, n) {\n    return s => s < t ? 0 : s > e ? 1 : n(fs(t, e, s));\n  }\n  function vo(t, e) {\n    t.min = e.min, t.max = e.max;\n  }\n  function xo(t, e) {\n    vo(t.x, e.x), vo(t.y, e.y);\n  }\n  function Po(t, e, n, s, i) {\n    return t = Ki(t -= e, 1 / n, s), void 0 !== i && (t = Ki(t, 1 / i, s)), t;\n  }\n  function wo(t, e, _ref78, o, r) {\n    let _ref79 = _slicedToArray(_ref78, 3),\n      n = _ref79[0],\n      s = _ref79[1],\n      i = _ref79[2];\n    !function (t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;\n      let i = arguments.length > 4 ? arguments[4] : undefined;\n      let o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : t;\n      let r = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : t;\n      if (wt.test(e)) {\n        e = parseFloat(e);\n        e = gs(r.min, r.max, e / 100) - r.min;\n      }\n      if (\"number\" != typeof e) return;\n      let a = gs(o.min, o.max, s);\n      t === o && (a -= e), t.min = Po(t.min, e, n, a, i), t.max = Po(t.max, e, n, a, i);\n    }(t, e[n], e[s], e[i], e.scale, o, r);\n  }\n  const To = [\"x\", \"scaleX\", \"originX\"],\n    So = [\"y\", \"scaleY\", \"originY\"];\n  function bo(t, e, n, s) {\n    wo(t.x, e, To, n ? n.x : void 0, s ? s.x : void 0), wo(t.y, e, So, n ? n.y : void 0, s ? s.y : void 0);\n  }\n  function Ao(t) {\n    return 0 === t.translate && 1 === t.scale;\n  }\n  function Eo(t) {\n    return Ao(t.x) && Ao(t.y);\n  }\n  function Co(t, e) {\n    return Math.round(t.x.min) === Math.round(e.x.min) && Math.round(t.x.max) === Math.round(e.x.max) && Math.round(t.y.min) === Math.round(e.y.min) && Math.round(t.y.max) === Math.round(e.y.max);\n  }\n  function Vo(t) {\n    return Ci(t.x) / Ci(t.y);\n  }\n  class Mo {\n    constructor() {\n      this.members = [];\n    }\n    add(t) {\n      Js(this.members, t), t.scheduleRender();\n    }\n    remove(t) {\n      if (Qs(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {\n        const t = this.members[this.members.length - 1];\n        t && this.promote(t);\n      }\n    }\n    relegate(t) {\n      const e = this.members.findIndex(e => t === e);\n      if (0 === e) return !1;\n      let n;\n      for (let t = e; t >= 0; t--) {\n        const e = this.members[t];\n        if (!1 !== e.isPresent) {\n          n = e;\n          break;\n        }\n      }\n      return !!n && (this.promote(n), !0);\n    }\n    promote(t, e) {\n      const n = this.lead;\n      if (t !== n && (this.prevLead = n, this.lead = t, t.show(), n)) {\n        n.instance && n.scheduleRender(), t.scheduleRender(), t.resumeFrom = n, e && (t.resumeFrom.preserveOpacity = !0), n.snapshot && (t.snapshot = n.snapshot, t.snapshot.latestValues = n.animationValues || n.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);\n        const s = t.options.crossfade;\n        !1 === s && n.hide();\n      }\n    }\n    exitAnimationComplete() {\n      this.members.forEach(t => {\n        const e = t.options,\n          n = t.resumingFrom;\n        e.onExitComplete && e.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();\n      });\n    }\n    scheduleRender() {\n      this.members.forEach(t => {\n        t.instance && t.scheduleRender(!1);\n      });\n    }\n    removeLeadSnapshot() {\n      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);\n    }\n  }\n  function Ro(t, e, n) {\n    let s = \"\";\n    const i = t.x.translate / e.x,\n      o = t.y.translate / e.y,\n      r = (null == n ? void 0 : n.z) || 0;\n    if ((i || o || r) && (s = `translate3d(${i}px, ${o}px, ${r}px) `), 1 === e.x && 1 === e.y || (s += `scale(${1 / e.x}, ${1 / e.y}) `), n) {\n      const t = n.transformPerspective,\n        e = n.rotate,\n        i = n.rotateX,\n        o = n.rotateY,\n        r = n.skewX,\n        a = n.skewY;\n      t && (s = `perspective(${t}px) ${s}`), e && (s += `rotate(${e}deg) `), i && (s += `rotateX(${i}deg) `), o && (s += `rotateY(${o}deg) `), r && (s += `skewX(${r}deg) `), a && (s += `skewY(${a}deg) `);\n    }\n    const a = t.x.scale * e.x,\n      l = t.y.scale * e.y;\n    return 1 === a && 1 === l || (s += `scale(${a}, ${l})`), s || \"none\";\n  }\n  const Do = (t, e) => t.depth - e.depth;\n  class ko {\n    constructor() {\n      this.children = [], this.isDirty = !1;\n    }\n    add(t) {\n      Js(this.children, t), this.isDirty = !0;\n    }\n    remove(t) {\n      Qs(this.children, t), this.isDirty = !0;\n    }\n    forEach(t) {\n      this.isDirty && this.children.sort(Do), this.isDirty = !1, this.children.forEach(t);\n    }\n  }\n  const Lo = {\n    hasAnimatedSinceResize: !0,\n    hasEverUpdated: !1\n  };\n  function Bo(t, e) {\n    const n = Ge.now(),\n      s = _ref80 => {\n        let i = _ref80.timestamp;\n        const o = i - n;\n        o >= e && (oe(s), t(o - e));\n      };\n    return ie.read(s, !0), () => oe(s);\n  }\n  function Fo(t, e, n) {\n    var s;\n    if (\"string\" == typeof t) {\n      let i = document;\n      e && (Ze(Boolean(e.current)), i = e.current), n ? (null !== (s = n[t]) && void 0 !== s || (n[t] = i.querySelectorAll(t)), t = n[t]) : t = i.querySelectorAll(t);\n    } else t instanceof Element && (t = [t]);\n    return Array.from(t || []);\n  }\n  const jo = new WeakMap();\n  function Oo(t, e) {\n    let n;\n    const s = () => {\n      const s = e.currentTime,\n        i = (null === s ? 0 : s.value) / 100;\n      n !== i && t(i), n = i;\n    };\n    return ie.update(s, !0), () => oe(s);\n  }\n  const Io = Wn(() => void 0 !== window.ScrollTimeline);\n  class Uo {\n    constructor(t) {\n      this.animations = t.filter(Boolean);\n    }\n    then(t, e) {\n      return Promise.all(this.animations).then(t).catch(e);\n    }\n    getAll(t) {\n      return this.animations[0][t];\n    }\n    setAll(t, e) {\n      for (let n = 0; n < this.animations.length; n++) this.animations[n][t] = e;\n    }\n    attachTimeline(t) {\n      const e = this.animations.map(e => {\n        if (!Io() || !e.attachTimeline) return e.pause(), Oo(t => {\n          e.time = e.duration * t;\n        }, t);\n        e.attachTimeline(t);\n      });\n      return () => {\n        e.forEach((t, e) => {\n          t && t(), this.animations[e].stop();\n        });\n      };\n    }\n    get time() {\n      return this.getAll(\"time\");\n    }\n    set time(t) {\n      this.setAll(\"time\", t);\n    }\n    get speed() {\n      return this.getAll(\"speed\");\n    }\n    set speed(t) {\n      this.setAll(\"speed\", t);\n    }\n    get duration() {\n      let t = 0;\n      for (let e = 0; e < this.animations.length; e++) t = Math.max(t, this.animations[e].duration);\n      return t;\n    }\n    runAll(t) {\n      this.animations.forEach(e => e[t]());\n    }\n    play() {\n      this.runAll(\"play\");\n    }\n    pause() {\n      this.runAll(\"pause\");\n    }\n    stop() {\n      this.runAll(\"stop\");\n    }\n    cancel() {\n      this.runAll(\"cancel\");\n    }\n    complete() {\n      this.runAll(\"complete\");\n    }\n  }\n  function Wo(t) {\n    return t instanceof SVGElement && \"svg\" !== t.tagName;\n  }\n  const No = {\n      current: null\n    },\n    zo = {\n      current: !1\n    };\n  function Ho() {\n    if (zo.current = !0, y) if (window.matchMedia) {\n      const t = window.matchMedia(\"(prefers-reduced-motion)\"),\n        e = () => No.current = t.matches;\n      t.addListener(e), e();\n    } else No.current = !1;\n  }\n  const $o = [...cn, bn, Rn],\n    Yo = Object.keys(U),\n    Xo = Yo.length,\n    Ko = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"],\n    Go = L.length;\n  class _o {\n    scrapeMotionValuesFromProps(t, e, n) {\n      return {};\n    }\n    constructor(_ref81) {\n      let t = _ref81.parent,\n        e = _ref81.props,\n        n = _ref81.presenceContext,\n        s = _ref81.reducedMotionConfig,\n        i = _ref81.blockInitialAnimation,\n        o = _ref81.visualState;\n      let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.resolveKeyframes = (t, e, n, s) => new this.KeyframeResolver(t, e, n, s, this), this.current = null, this.children = new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map(), this.KeyframeResolver = yn, this.features = {}, this.valueSubscriptions = new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify(\"Update\", this.latestValues), this.render = () => {\n        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));\n      }, this.scheduleRender = () => ie.render(this.render, !1, !0);\n      const a = o.latestValues,\n        l = o.renderState;\n      this.latestValues = a, this.baseTarget = _objectSpread({}, a), this.initialValues = e.initial ? _objectSpread({}, a) : {}, this.renderState = l, this.parent = t, this.props = e, this.presenceContext = n, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = r, this.blockInitialAnimation = Boolean(i), this.isControllingVariants = B(e), this.isVariantNode = F(e), this.isVariantNode && (this.variantChildren = new Set()), this.manuallyAnimateOnMount = Boolean(t && t.current);\n      const _this$scrapeMotionVal = this.scrapeMotionValuesFromProps(e, {}, this),\n        u = _this$scrapeMotionVal.willChange,\n        c = _objectWithoutProperties(_this$scrapeMotionVal, _excluded13);\n      for (const t in c) {\n        const e = c[t];\n        void 0 !== a[t] && tt(e) && (e.set(a[t], !1), Zs(u) && u.add(t));\n      }\n    }\n    mount(t) {\n      this.current = t, jo.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, e) => this.bindToMotionValue(e, t)), zo.current || Ho(), this.shouldReduceMotion = \"never\" !== this.reducedMotionConfig && (\"always\" === this.reducedMotionConfig || No.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n      var t;\n      jo.delete(this.current), this.projection && this.projection.unmount(), oe(this.notifyUpdate), oe(this.render), this.valueSubscriptions.forEach(t => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);\n      for (const t in this.events) this.events[t].clear();\n      for (const e in this.features) null === (t = this.features[e]) || void 0 === t || t.unmount();\n      this.current = null;\n    }\n    bindToMotionValue(t, e) {\n      const n = J.has(t),\n        s = e.on(\"change\", e => {\n          this.latestValues[t] = e, this.props.onUpdate && ie.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0);\n        }),\n        i = e.on(\"renderRequest\", this.scheduleRender);\n      this.valueSubscriptions.set(t, () => {\n        s(), i(), e.owner && e.stop();\n      });\n    }\n    sortNodePosition(t) {\n      return this.current && this.sortInstanceNodePosition && this.type === t.type ? this.sortInstanceNodePosition(this.current, t.current) : 0;\n    }\n    loadFeatures(_ref82, n, s, i) {\n      let t = _ref82.children,\n        e = _objectWithoutProperties(_ref82, _excluded14);\n      let o, r;\n      for (let t = 0; t < Xo; t++) {\n        const n = Yo[t],\n          _U$n = U[n],\n          s = _U$n.isEnabled,\n          i = _U$n.Feature,\n          a = _U$n.ProjectionNode,\n          l = _U$n.MeasureLayout;\n        a && (o = a), s(e) && (!this.features[n] && i && (this.features[n] = new i(this)), l && (r = l));\n      }\n      if ((\"html\" === this.type || \"svg\" === this.type) && !this.projection && o) {\n        this.projection = new o(this.latestValues, function t(e) {\n          if (e) return !1 !== e.options.allowProjection ? e.projection : t(e.parent);\n        }(this.parent));\n        const t = e.layoutId,\n          n = e.layout,\n          s = e.drag,\n          r = e.dragConstraints,\n          a = e.layoutScroll,\n          l = e.layoutRoot;\n        this.projection.setOptions({\n          layoutId: t,\n          layout: n,\n          alwaysMeasureLayout: Boolean(s) || r && V(r),\n          visualElement: this,\n          scheduleRender: () => this.scheduleRender(),\n          animationType: \"string\" == typeof n ? n : \"both\",\n          initialPromotionConfig: i,\n          layoutScroll: a,\n          layoutRoot: l\n        });\n      }\n      return r;\n    }\n    updateFeatures() {\n      for (const t in this.features) {\n        const e = this.features[t];\n        e.isMounted ? e.update() : (e.mount(), e.isMounted = !0);\n      }\n    }\n    triggerBuild() {\n      this.build(this.renderState, this.latestValues, this.options, this.props);\n    }\n    measureViewportBox() {\n      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {\n        x: {\n          min: 0,\n          max: 0\n        },\n        y: {\n          min: 0,\n          max: 0\n        }\n      };\n    }\n    getStaticValue(t) {\n      return this.latestValues[t];\n    }\n    setStaticValue(t, e) {\n      this.latestValues[t] = e;\n    }\n    update(t, e) {\n      (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;\n      for (let e = 0; e < Ko.length; e++) {\n        const n = Ko[e];\n        this.propEventSubscriptions[n] && (this.propEventSubscriptions[n](), delete this.propEventSubscriptions[n]);\n        const s = t[\"on\" + n];\n        s && (this.propEventSubscriptions[n] = this.on(n, s));\n      }\n      this.prevMotionValues = function (t, e, n) {\n        const s = e.willChange;\n        for (const i in e) {\n          const o = e[i],\n            r = n[i];\n          if (tt(o)) t.addValue(i, o), Zs(s) && s.add(i);else if (tt(r)) t.addValue(i, si(o, {\n            owner: t\n          })), Zs(s) && s.remove(i);else if (r !== o) if (t.hasValue(i)) {\n            const e = t.getValue(i);\n            !0 === e.liveStyle ? e.jump(o) : e.hasAnimated || e.set(o);\n          } else {\n            const e = t.getStaticValue(i);\n            t.addValue(i, si(void 0 !== e ? e : o, {\n              owner: t\n            }));\n          }\n        }\n        for (const s in n) void 0 === e[s] && t.removeValue(s);\n        return e;\n      }(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();\n    }\n    getProps() {\n      return this.props;\n    }\n    getVariant(t) {\n      return this.props.variants ? this.props.variants[t] : void 0;\n    }\n    getDefaultTransition() {\n      return this.props.transition;\n    }\n    getTransformPagePoint() {\n      return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;\n    }\n    getVariantContext() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n      if (t) return this.parent ? this.parent.getVariantContext() : void 0;\n      if (!this.isControllingVariants) {\n        const t = this.parent && this.parent.getVariantContext() || {};\n        return void 0 !== this.props.initial && (t.initial = this.props.initial), t;\n      }\n      const e = {};\n      for (let t = 0; t < Go; t++) {\n        const n = L[t],\n          s = this.props[n];\n        (R(s) || !1 === s) && (e[n] = s);\n      }\n      return e;\n    }\n    addVariantChild(t) {\n      const e = this.getClosestVariantNode();\n      if (e) return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t);\n    }\n    addValue(t, e) {\n      const n = this.values.get(t);\n      e !== n && (n && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get());\n    }\n    removeValue(t) {\n      this.values.delete(t);\n      const e = this.valueSubscriptions.get(t);\n      e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);\n    }\n    hasValue(t) {\n      return this.values.has(t);\n    }\n    getValue(t, e) {\n      if (this.props.values && this.props.values[t]) return this.props.values[t];\n      let n = this.values.get(t);\n      return void 0 === n && void 0 !== e && (n = si(null === e ? void 0 : e, {\n        owner: this\n      }), this.addValue(t, n)), n;\n    }\n    readValue(t, e) {\n      var n;\n      let s = void 0 === this.latestValues[t] && this.current ? null !== (n = this.getBaseTargetFromProps(this.props, t)) && void 0 !== n ? n : this.readValueFromInstance(this.current, t, this.options) : this.latestValues[t];\n      var i;\n      return null != s && (\"string\" == typeof s && (Je(s) || _e(s)) ? s = parseFloat(s) : (i = s, !$o.find(un(i)) && Rn.test(e) && (s = On(t, e))), this.setBaseTarget(t, tt(s) ? s.get() : s)), tt(s) ? s.get() : s;\n    }\n    setBaseTarget(t, e) {\n      this.baseTarget[t] = e;\n    }\n    getBaseTarget(t) {\n      var e;\n      const n = this.props.initial;\n      let s;\n      if (\"string\" == typeof n || \"object\" == typeof n) {\n        const i = Zt(this.props, n, null === (e = this.presenceContext) || void 0 === e ? void 0 : e.custom);\n        i && (s = i[t]);\n      }\n      if (n && void 0 !== s) return s;\n      const i = this.getBaseTargetFromProps(this.props, t);\n      return void 0 === i || tt(i) ? void 0 !== this.initialValues[t] && void 0 === s ? void 0 : this.baseTarget[t] : i;\n    }\n    on(t, e) {\n      return this.events[t] || (this.events[t] = new ti()), this.events[t].add(e);\n    }\n    notify(t) {\n      for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        e[_key2 - 1] = arguments[_key2];\n      }\n      this.events[t] && this.events[t].notify(...e);\n    }\n  }\n  class qo extends _o {\n    constructor() {\n      super(...arguments), this.KeyframeResolver = Un;\n    }\n    sortInstanceNodePosition(t, e) {\n      return 2 & t.compareDocumentPosition(e) ? 1 : -1;\n    }\n    getBaseTargetFromProps(t, e) {\n      return t.style ? t.style[e] : void 0;\n    }\n    removeValueFromRenderState(t, _ref83) {\n      let e = _ref83.vars,\n        n = _ref83.style;\n      delete e[t], delete n[t];\n    }\n  }\n  class Zo extends qo {\n    constructor() {\n      super(...arguments), this.type = \"svg\", this.isSVGTag = !1;\n    }\n    getBaseTargetFromProps(t, e) {\n      return t[e];\n    }\n    readValueFromInstance(t, e) {\n      if (J.has(e)) {\n        const t = jn(e);\n        return t && t.default || 0;\n      }\n      return e = Kt.has(e) ? e : P(e), t.getAttribute(e);\n    }\n    measureInstanceViewportBox() {\n      return {\n        x: {\n          min: 0,\n          max: 0\n        },\n        y: {\n          min: 0,\n          max: 0\n        }\n      };\n    }\n    scrapeMotionValuesFromProps(t, e, n) {\n      return qt(t, e, n);\n    }\n    build(t, e, n, s) {\n      Nt(t, e, n, this.isSVGTag, s.transformTemplate);\n    }\n    renderInstance(t, e, n, s) {\n      Gt(t, e, 0, s);\n    }\n    mount(t) {\n      this.isSVGTag = Ht(t.tagName), super.mount(t);\n    }\n  }\n  class Jo extends qo {\n    constructor() {\n      super(...arguments), this.type = \"html\";\n    }\n    readValueFromInstance(t, e) {\n      if (J.has(e)) {\n        const t = jn(e);\n        return t && t.default || 0;\n      }\n      {\n        const s = (n = t, window.getComputedStyle(n)),\n          i = (ot(e) ? s.getPropertyValue(e) : s[e]) || 0;\n        return \"string\" == typeof i ? i.trim() : i;\n      }\n      var n;\n    }\n    measureInstanceViewportBox(t, _ref84) {\n      let e = _ref84.transformPagePoint;\n      return so(t, e);\n    }\n    build(t, e, n, s) {\n      Vt(t, e, n, s.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(t, e, n) {\n      return _t(t, e, n);\n    }\n    handleChildMotionValue() {\n      this.childSubscription && (this.childSubscription(), delete this.childSubscription);\n      const t = this.props.children;\n      tt(t) && (this.childSubscription = t.on(\"change\", t => {\n        this.current && (this.current.textContent = \"\" + t);\n      }));\n    }\n    renderInstance(t, e, n, s) {\n      Xt(t, e, n, s);\n    }\n  }\n  function Qo(t) {\n    const e = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n          renderState: {\n            transform: {},\n            transformOrigin: {},\n            style: {},\n            vars: {},\n            attrs: {}\n          },\n          latestValues: {}\n        }\n      },\n      n = Wo(t) ? new Zo(e, {\n        enableHardwareAcceleration: !1\n      }) : new Jo(e, {\n        enableHardwareAcceleration: !0\n      });\n    n.mount(t), jo.set(t, n);\n  }\n  function tr(t, e, n) {\n    const s = tt(t) ? t : si(t);\n    return s.start(qs(\"\", s, e, n)), s.animation;\n  }\n  function er(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    const n = qn(_objectSpread({\n        keyframes: [0, e]\n      }, t)),\n      s = Math.min(Bs(n), 2e4);\n    return {\n      type: \"keyframes\",\n      ease: t => n.next(s * t).value / e,\n      duration: Oe(s)\n    };\n  }\n  function nr(t, e, n, s) {\n    var i;\n    return \"number\" == typeof e ? e : e.startsWith(\"-\") || e.startsWith(\"+\") ? Math.max(0, t + parseFloat(e)) : \"<\" === e ? n : null !== (i = s.get(e)) && void 0 !== i ? i : t;\n  }\n  const sr = (t, e, n) => {\n    const s = e - t;\n    return ((n - t) % s + s) % s + t;\n  };\n  function ir(t, e) {\n    return ss(t) ? t[sr(0, t.length, e)] : t;\n  }\n  function or(t, e, n, s, i, o) {\n    !function (t, e, n) {\n      for (let s = 0; s < t.length; s++) {\n        const i = t[s];\n        i.at > e && i.at < n && (Qs(t, i), s--);\n      }\n    }(t, i, o);\n    for (let r = 0; r < e.length; r++) t.push({\n      value: e[r],\n      at: gs(i, o, s[r]),\n      easing: ir(n, r)\n    });\n  }\n  function rr(t, e) {\n    return t.at === e.at ? null === t.value ? 1 : null === e.value ? -1 : 0 : t.at - e.at;\n  }\n  function ar(t, e) {\n    return !e.has(t) && e.set(t, {}), e.get(t);\n  }\n  function lr(t, e) {\n    return e[t] || (e[t] = []), e[t];\n  }\n  function ur(t) {\n    return Array.isArray(t) ? t : [t];\n  }\n  function cr(t, e) {\n    return t[e] ? _objectSpread(_objectSpread({}, t), t[e]) : _objectSpread({}, t);\n  }\n  const hr = t => \"number\" == typeof t,\n    dr = t => t.every(hr);\n  function mr(t, e, n, s) {\n    const i = Fo(t, s),\n      o = i.length,\n      r = [];\n    for (let t = 0; t < o; t++) {\n      const s = i[t];\n      jo.has(s) || Qo(s);\n      const a = jo.get(s),\n        l = _objectSpread({}, n);\n      \"function\" == typeof l.delay && (l.delay = l.delay(t, o)), r.push(...ai(a, _objectSpread(_objectSpread({}, e), {}, {\n        transition: l\n      }), {}));\n    }\n    return new Uo(r);\n  }\n  function pr(t, e, n) {\n    const s = [];\n    return function (t) {\n      let _ref85 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let s = arguments.length > 2 ? arguments[2] : undefined;\n      let _ref85$defaultTransit = _ref85.defaultTransition,\n        e = _ref85$defaultTransit === void 0 ? {} : _ref85$defaultTransit,\n        n = _objectWithoutProperties(_ref85, _excluded15);\n      const i = e.duration || .3,\n        o = new Map(),\n        r = new Map(),\n        a = {},\n        l = new Map();\n      let u = 0,\n        c = 0,\n        h = 0;\n      for (let n = 0; n < t.length; n++) {\n        const o = t[n];\n        if (\"string\" == typeof o) {\n          l.set(o, c);\n          continue;\n        }\n        if (!Array.isArray(o)) {\n          l.set(o.name, nr(c, o.at, u, l));\n          continue;\n        }\n        let _o4 = _slicedToArray(o, 3),\n          d = _o4[0],\n          m = _o4[1],\n          _o4$ = _o4[2],\n          p = _o4$ === void 0 ? {} : _o4$;\n        void 0 !== p.at && (c = nr(c, p.at, u, l));\n        let f = 0;\n        const g = function (t, n, s) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n          let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n          const a = ur(t),\n            _n$delay = n.delay,\n            l = _n$delay === void 0 ? 0 : _n$delay,\n            _n$times = n.times,\n            u = _n$times === void 0 ? ks(a) : _n$times,\n            _n$type = n.type,\n            d = _n$type === void 0 ? \"keyframes\" : _n$type,\n            m = _objectWithoutProperties(n, _excluded16);\n          let _n$ease = n.ease,\n            p = _n$ease === void 0 ? e.ease || \"easeOut\" : _n$ease,\n            g = n.duration;\n          const y = \"function\" == typeof l ? l(o, r) : l,\n            v = a.length;\n          if (v <= 2 && \"spring\" === d) {\n            let t = 100;\n            if (2 === v && dr(a)) {\n              const e = a[1] - a[0];\n              t = Math.abs(e);\n            }\n            const e = _objectSpread({}, m);\n            void 0 !== g && (e.duration = je(g));\n            const n = er(e, t);\n            p = n.ease, g = n.duration;\n          }\n          null != g || (g = i);\n          const x = c + y,\n            P = x + g;\n          1 === u.length && 0 === u[0] && (u[1] = 1);\n          const w = u.length - a.length;\n          w > 0 && Ds(u, w), 1 === a.length && a.unshift(null), or(s, a, p, u, x, P), f = Math.max(y + g, f), h = Math.max(P, h);\n        };\n        if (tt(d)) {\n          g(m, p, lr(\"default\", ar(d, r)));\n        } else {\n          const t = Fo(d, s, a),\n            e = t.length;\n          for (let n = 0; n < e; n++) {\n            m = m, p = p;\n            const s = ar(t[n], r);\n            for (const t in m) g(m[t], cr(p, t), lr(t, s), n, e);\n          }\n        }\n        u = c, c += f;\n      }\n      return r.forEach((t, s) => {\n        for (const i in t) {\n          const r = t[i];\n          r.sort(rr);\n          const a = [],\n            l = [],\n            u = [];\n          for (let t = 0; t < r.length; t++) {\n            const _r$t = r[t],\n              e = _r$t.at,\n              n = _r$t.value,\n              s = _r$t.easing;\n            a.push(n), l.push(fs(0, h, e)), u.push(s || \"easeOut\");\n          }\n          0 !== l[0] && (l.unshift(0), a.unshift(a[0]), u.unshift(\"easeInOut\")), 1 !== l[l.length - 1] && (l.push(1), a.push(null)), o.has(s) || o.set(s, {\n            keyframes: {},\n            transition: {}\n          });\n          const c = o.get(s);\n          c.keyframes[i] = a, c.transition[i] = _objectSpread(_objectSpread({}, e), {}, {\n            duration: h,\n            ease: u,\n            times: l\n          }, n);\n        }\n      }), o;\n    }(t, e, n).forEach((_ref86, n) => {\n      let t = _ref86.keyframes,\n        e = _ref86.transition;\n      let i;\n      i = tt(n) ? tr(n, t.default, e.default) : mr(n, t, e), s.push(i);\n    }), new Uo(s);\n  }\n  const fr = t => function (e, n, s) {\n      let i;\n      var o;\n      return o = e, i = Array.isArray(o) && Array.isArray(o[0]) ? pr(e, n, t) : function (t) {\n        return \"object\" == typeof t && !Array.isArray(t);\n      }(n) ? mr(e, n, s, t) : tr(e, n, s), t && t.animations.push(i), i;\n    },\n    gr = fr(),\n    yr = new WeakMap();\n  let vr;\n  function xr(_ref87) {\n    let t = _ref87.target,\n      e = _ref87.contentRect,\n      n = _ref87.borderBoxSize;\n    var s;\n    null === (s = yr.get(t)) || void 0 === s || s.forEach(s => {\n      s({\n        target: t,\n        contentSize: e,\n        get size() {\n          return function (t, e) {\n            if (e) {\n              const _e$ = e[0],\n                t = _e$.inlineSize,\n                n = _e$.blockSize;\n              return {\n                width: t,\n                height: n\n              };\n            }\n            return t instanceof SVGElement && \"getBBox\" in t ? t.getBBox() : {\n              width: t.offsetWidth,\n              height: t.offsetHeight\n            };\n          }(t, n);\n        }\n      });\n    });\n  }\n  function Pr(t) {\n    t.forEach(xr);\n  }\n  function wr(t, e) {\n    vr || \"undefined\" != typeof ResizeObserver && (vr = new ResizeObserver(Pr));\n    const n = Fo(t);\n    return n.forEach(t => {\n      let n = yr.get(t);\n      n || (n = new Set(), yr.set(t, n)), n.add(e), null == vr || vr.observe(t);\n    }), () => {\n      n.forEach(t => {\n        const n = yr.get(t);\n        null == n || n.delete(e), (null == n ? void 0 : n.size) || null == vr || vr.unobserve(t);\n      });\n    };\n  }\n  const Tr = new Set();\n  let Sr;\n  function br(t) {\n    return Tr.add(t), Sr || (Sr = () => {\n      const t = {\n          width: window.innerWidth,\n          height: window.innerHeight\n        },\n        e = {\n          target: window,\n          size: t,\n          contentSize: t\n        };\n      Tr.forEach(t => t(e));\n    }, window.addEventListener(\"resize\", Sr)), () => {\n      Tr.delete(t), !Tr.size && Sr && (Sr = void 0);\n    };\n  }\n  const Ar = {\n    x: {\n      length: \"Width\",\n      position: \"Left\"\n    },\n    y: {\n      length: \"Height\",\n      position: \"Top\"\n    }\n  };\n  function Er(t, e, n, s) {\n    const i = n[e],\n      _Ar$e = Ar[e],\n      o = _Ar$e.length,\n      r = _Ar$e.position,\n      a = i.current,\n      l = n.time;\n    i.current = t[\"scroll\" + r], i.scrollLength = t[\"scroll\" + o] - t[\"client\" + o], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = fs(0, i.scrollLength, i.current);\n    const u = s - l;\n    i.velocity = u > 50 ? 0 : Hn(i.current - a, u);\n  }\n  const Cr = {\n      Enter: [[0, 1], [1, 1]],\n      Exit: [[0, 0], [1, 0]],\n      Any: [[1, 0], [0, 1]],\n      All: [[0, 0], [1, 1]]\n    },\n    Vr = {\n      start: 0,\n      center: .5,\n      end: 1\n    };\n  function Mr(t, e) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let s = 0;\n    if (t in Vr && (t = Vr[t]), \"string\" == typeof t) {\n      const e = parseFloat(t);\n      t.endsWith(\"px\") ? s = e : t.endsWith(\"%\") ? t = e / 100 : t.endsWith(\"vw\") ? s = e / 100 * document.documentElement.clientWidth : t.endsWith(\"vh\") ? s = e / 100 * document.documentElement.clientHeight : t = e;\n    }\n    return \"number\" == typeof t && (s = e * t), n + s;\n  }\n  const Rr = [0, 0];\n  function Dr(t, e, n, s) {\n    let i = Array.isArray(t) ? t : Rr,\n      o = 0,\n      r = 0;\n    return \"number\" == typeof t ? i = [t, t] : \"string\" == typeof t && (i = (t = t.trim()).includes(\" \") ? t.split(\" \") : [t, Vr[t] ? t : \"0\"]), o = Mr(i[0], n, s), r = Mr(i[1], e), o - r;\n  }\n  const kr = {\n    x: 0,\n    y: 0\n  };\n  function Lr(t, e, n) {\n    const _n$offset = n.offset,\n      s = _n$offset === void 0 ? Cr.All : _n$offset,\n      _n$target = n.target,\n      i = _n$target === void 0 ? t : _n$target,\n      _n$axis = n.axis,\n      o = _n$axis === void 0 ? \"y\" : _n$axis,\n      r = \"y\" === o ? \"height\" : \"width\",\n      a = i !== t ? function (t, e) {\n        const n = {\n          x: 0,\n          y: 0\n        };\n        let s = t;\n        for (; s && s !== e;) if (s instanceof HTMLElement) n.x += s.offsetLeft, n.y += s.offsetTop, s = s.offsetParent;else if (\"svg\" === s.tagName) {\n          const t = s.getBoundingClientRect();\n          s = s.parentElement;\n          const e = s.getBoundingClientRect();\n          n.x += t.left - e.left, n.y += t.top - e.top;\n        } else {\n          if (!(s instanceof SVGGraphicsElement)) break;\n          {\n            const _s$getBBox = s.getBBox(),\n              t = _s$getBBox.x,\n              e = _s$getBBox.y;\n            n.x += t, n.y += e;\n            let i = null,\n              o = s.parentNode;\n            for (; !i;) \"svg\" === o.tagName && (i = o), o = s.parentNode;\n            s = i;\n          }\n        }\n        return n;\n      }(i, t) : kr,\n      l = i === t ? {\n        width: t.scrollWidth,\n        height: t.scrollHeight\n      } : function (t) {\n        return \"getBBox\" in t && \"svg\" !== t.tagName ? t.getBBox() : {\n          width: t.clientWidth,\n          height: t.clientHeight\n        };\n      }(i),\n      u = {\n        width: t.clientWidth,\n        height: t.clientHeight\n      };\n    e[o].offset.length = 0;\n    let c = !e[o].interpolate;\n    const h = s.length;\n    for (let t = 0; t < h; t++) {\n      const n = Dr(s[t], u[r], l[r], a[o]);\n      c || n === e[o].interpolatorOffsets[t] || (c = !0), e[o].offset[t] = n;\n    }\n    c && (e[o].interpolate = Rs(e[o].offset, ks(s)), e[o].interpolatorOffsets = [...e[o].offset]), e[o].progress = e[o].interpolate(e[o].current);\n  }\n  function Br(t, e, n) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return {\n      measure: () => function (t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t;\n        let n = arguments.length > 2 ? arguments[2] : undefined;\n        if (n.x.targetOffset = 0, n.y.targetOffset = 0, e !== t) {\n          let s = e;\n          for (; s && s !== t;) n.x.targetOffset += s.offsetLeft, n.y.targetOffset += s.offsetTop, s = s.offsetParent;\n        }\n        n.x.targetLength = e === t ? e.scrollWidth : e.clientWidth, n.y.targetLength = e === t ? e.scrollHeight : e.clientHeight, n.x.containerLength = t.clientWidth, n.y.containerLength = t.clientHeight;\n      }(t, s.target, n),\n      update: e => {\n        !function (t, e, n) {\n          Er(t, \"x\", e, n), Er(t, \"y\", e, n), e.time = n;\n        }(t, n, e), (s.offset || s.target) && Lr(t, n, s);\n      },\n      notify: () => e(n)\n    };\n  }\n  const Fr = new WeakMap(),\n    jr = new WeakMap(),\n    Or = new WeakMap(),\n    Ir = t => t === document.documentElement ? window : t;\n  function Ur(t) {\n    let _ref88 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let _ref88$container = _ref88.container,\n      e = _ref88$container === void 0 ? document.documentElement : _ref88$container,\n      n = _objectWithoutProperties(_ref88, _excluded17);\n    let s = Or.get(e);\n    s || (s = new Set(), Or.set(e, s));\n    const i = Br(e, t, {\n      time: 0,\n      x: {\n        current: 0,\n        offset: [],\n        progress: 0,\n        scrollLength: 0,\n        targetOffset: 0,\n        targetLength: 0,\n        containerLength: 0,\n        velocity: 0\n      },\n      y: {\n        current: 0,\n        offset: [],\n        progress: 0,\n        scrollLength: 0,\n        targetOffset: 0,\n        targetLength: 0,\n        containerLength: 0,\n        velocity: 0\n      }\n    }, n);\n    if (s.add(i), !Fr.has(e)) {\n      const t = () => {\n          for (const t of s) t.measure();\n        },\n        n = () => {\n          for (const t of s) t.update(re.timestamp);\n        },\n        i = () => {\n          for (const t of s) t.notify();\n        },\n        a = () => {\n          ie.read(t, !1, !0), ie.read(n, !1, !0), ie.update(i, !1, !0);\n        };\n      Fr.set(e, a);\n      const l = Ir(e);\n      window.addEventListener(\"resize\", a, {\n        passive: !0\n      }), e !== document.documentElement && jr.set(e, (r = a, \"function\" == typeof (o = e) ? br(o) : wr(o, r))), l.addEventListener(\"scroll\", a, {\n        passive: !0\n      });\n    }\n    var o, r;\n    const a = Fr.get(e);\n    return ie.read(a, !1, !0), () => {\n      var t;\n      oe(a);\n      const n = Or.get(e);\n      if (!n) return;\n      if (n.delete(i), n.size) return;\n      const s = Fr.get(e);\n      Fr.delete(e), s && (Ir(e).removeEventListener(\"scroll\", s), null === (t = jr.get(e)) || void 0 === t || t(), window.removeEventListener(\"resize\", s));\n    };\n  }\n  const Wr = new Map();\n  function Nr() {\n    let _ref89 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref89$source = _ref89.source,\n      t = _ref89$source === void 0 ? document.documentElement : _ref89$source,\n      _ref89$axis = _ref89.axis,\n      e = _ref89$axis === void 0 ? \"y\" : _ref89$axis;\n    Wr.has(t) || Wr.set(t, {});\n    const n = Wr.get(t);\n    return n[e] || (n[e] = Io() ? new ScrollTimeline({\n      source: t,\n      axis: e\n    }) : function (_ref90) {\n      let t = _ref90.source,\n        _ref90$axis = _ref90.axis,\n        e = _ref90$axis === void 0 ? \"y\" : _ref90$axis;\n      const n = {\n          value: 0\n        },\n        s = Ur(t => {\n          n.value = 100 * t[e].progress;\n        }, {\n          container: t,\n          axis: e\n        });\n      return {\n        currentTime: n,\n        cancel: s\n      };\n    }({\n      source: t,\n      axis: e\n    })), n[e];\n  }\n  const zr = {\n    some: 0,\n    all: 1\n  };\n  function Hr(t, e) {\n    let _ref91 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      n = _ref91.root,\n      s = _ref91.margin,\n      _ref91$amount = _ref91.amount,\n      i = _ref91$amount === void 0 ? \"some\" : _ref91$amount;\n    const o = Fo(t),\n      r = new WeakMap(),\n      a = new IntersectionObserver(t => {\n        t.forEach(t => {\n          const n = r.get(t.target);\n          if (t.isIntersecting !== Boolean(n)) if (t.isIntersecting) {\n            const n = e(t);\n            \"function\" == typeof n ? r.set(t.target, n) : a.unobserve(t.target);\n          } else n && (n(t), r.delete(t.target));\n        });\n      }, {\n        root: n,\n        rootMargin: s,\n        threshold: \"number\" == typeof i ? i : zr[i]\n      });\n    return o.forEach(t => a.observe(t)), () => a.disconnect();\n  }\n  function $r() {\n    const e = !Array.isArray(arguments.length <= 0 ? undefined : arguments[0]),\n      n = e ? 0 : -1,\n      s = 0 + n < 0 || arguments.length <= 0 + n ? undefined : arguments[0 + n],\n      i = 1 + n < 0 || arguments.length <= 1 + n ? undefined : arguments[1 + n],\n      o = 2 + n < 0 || arguments.length <= 2 + n ? undefined : arguments[2 + n],\n      r = 3 + n < 0 || arguments.length <= 3 + n ? undefined : arguments[3 + n],\n      a = Rs(i, o, _objectSpread({\n        mixer: (l = o[0], (t => t && \"object\" == typeof t && t.mix)(l) ? l.mix : void 0)\n      }, r));\n    var l;\n    return e ? a(s) : a;\n  }\n  const Yr = ie,\n    Xr = b.reduce((t, e) => (t[e] = t => oe(t), t), {}),\n    Kr = [\"\", \"X\", \"Y\", \"Z\"],\n    Gr = {\n      visibility: \"hidden\"\n    };\n  let _r = 0;\n  const qr = {\n    type: \"projectionFrame\",\n    totalNodes: 0,\n    resolvedTargetDeltas: 0,\n    recalculatedProjection: 0\n  };\n  function Zr(t, e, n, s) {\n    const i = e.latestValues;\n    i[t] && (n[t] = i[t], e.setStaticValue(t, 0), s && (s[t] = 0));\n  }\n  function Jr(_ref92) {\n    let t = _ref92.attachResizeListener,\n      e = _ref92.defaultParent,\n      n = _ref92.measureScroll,\n      s = _ref92.checkIsScrollRoot,\n      i = _ref92.resetTransform;\n    return class {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null == e ? void 0 : e();\n        this.id = _r++, this.animationId = 0, this.children = new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {\n          x: 1,\n          y: 1\n        }, this.eventHandlers = new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {\n          this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());\n        }, this.updateProjection = () => {\n          var t;\n          this.projectionUpdateScheduled = !1, qr.totalNodes = qr.resolvedTargetDeltas = qr.recalculatedProjection = 0, this.nodes.forEach(ea), this.nodes.forEach(la), this.nodes.forEach(ua), this.nodes.forEach(na), t = qr, window.MotionDebug && window.MotionDebug.record(t);\n        }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map(), this.latestValues = t, this.root = n ? n.root || n : this, this.path = n ? [...n.path, n] : [], this.parent = n, this.depth = n ? n.depth + 1 : 0;\n        for (let t = 0; t < this.path.length; t++) this.path[t].shouldResetTransform = !0;\n        this.root === this && (this.nodes = new ko());\n      }\n      addEventListener(t, e) {\n        return this.eventHandlers.has(t) || this.eventHandlers.set(t, new ti()), this.eventHandlers.get(t).add(e);\n      }\n      notifyListeners(t) {\n        const n = this.eventHandlers.get(t);\n        for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          e[_key3 - 1] = arguments[_key3];\n        }\n        n && n.notify(...e);\n      }\n      hasListeners(t) {\n        return this.eventHandlers.has(t);\n      }\n      mount(e) {\n        let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root.hasTreeAnimated;\n        if (this.instance) return;\n        this.isSVG = Wo(e), this.instance = e;\n        const _this$options10 = this.options,\n          s = _this$options10.layoutId,\n          i = _this$options10.layout,\n          o = _this$options10.visualElement;\n        if (o && !o.current && o.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), n && (i || s) && (this.isLayoutDirty = !0), t) {\n          let n;\n          const s = () => this.root.updateBlockedByResize = !1;\n          t(e, () => {\n            this.root.updateBlockedByResize = !0, n && n(), n = Bo(s, 250), Lo.hasAnimatedSinceResize && (Lo.hasAnimatedSinceResize = !1, this.nodes.forEach(aa));\n          });\n        }\n        s && this.root.registerSharedNode(s, this), !1 !== this.options.animate && o && (s || i) && this.addEventListener(\"didUpdate\", _ref93 => {\n          let t = _ref93.delta,\n            e = _ref93.hasLayoutChanged,\n            n = _ref93.hasRelativeTargetChanged,\n            s = _ref93.layout;\n          if (this.isTreeAnimationBlocked()) return this.target = void 0, void (this.relativeTarget = void 0);\n          const i = this.options.transition || o.getDefaultTransition() || fa,\n            _o$getProps = o.getProps(),\n            r = _o$getProps.onLayoutAnimationStart,\n            a = _o$getProps.onLayoutAnimationComplete,\n            l = !this.targetLayout || !Co(this.targetLayout, s) || n,\n            u = !e && n;\n          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || e && (l || !this.currentAnimation)) {\n            this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, u);\n            const e = _objectSpread(_objectSpread({}, ze(i, \"layout\")), {}, {\n              onPlay: r,\n              onComplete: a\n            });\n            (o.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e);\n          } else e || aa(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();\n          this.targetLayout = s;\n        });\n      }\n      unmount() {\n        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);\n        const t = this.getStack();\n        t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, oe(this.updateProjection);\n      }\n      blockUpdate() {\n        this.updateManuallyBlocked = !0;\n      }\n      unblockUpdate() {\n        this.updateManuallyBlocked = !1;\n      }\n      isUpdateBlocked() {\n        return this.updateManuallyBlocked || this.updateBlockedByResize;\n      }\n      isTreeAnimationBlocked() {\n        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;\n      }\n      startUpdate() {\n        this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(ca), this.animationId++);\n      }\n      getTransformTemplate() {\n        const t = this.options.visualElement;\n        return t && t.getProps().transformTemplate;\n      }\n      willUpdate() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n        if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) return void (this.options.onExitComplete && this.options.onExitComplete());\n        if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;\n        this.isLayoutDirty = !0;\n        for (let t = 0; t < this.path.length; t++) {\n          const e = this.path[t];\n          e.shouldResetTransform = !0, e.updateScroll(\"snapshot\"), e.options.layoutRoot && e.willUpdate(!1);\n        }\n        const _this$options11 = this.options,\n          e = _this$options11.layoutId,\n          n = _this$options11.layout;\n        if (void 0 === e && !n) return;\n        const s = this.getTransformTemplate();\n        this.prevTransformTemplateValue = s ? s(this.latestValues, \"\") : void 0, this.updateSnapshot(), t && this.notifyListeners(\"willUpdate\");\n      }\n      update() {\n        this.updateScheduled = !1;\n        if (this.isUpdateBlocked()) return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach(ia);\n        this.isUpdating || this.nodes.forEach(oa), this.isUpdating = !1, window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(), this.nodes.forEach(ra), this.nodes.forEach(Qr), this.nodes.forEach(ta), this.clearAllSnapshots();\n        const t = Ge.now();\n        re.delta = ct(0, 1e3 / 60, t - re.timestamp), re.timestamp = t, re.isProcessing = !0, ae.update.process(re), ae.preRender.process(re), ae.render.process(re), re.isProcessing = !1;\n      }\n      didUpdate() {\n        this.updateScheduled || (this.updateScheduled = !0, E.read(() => this.update()));\n      }\n      clearAllSnapshots() {\n        this.nodes.forEach(sa), this.sharedNodes.forEach(ha);\n      }\n      scheduleUpdateProjection() {\n        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ie.preRender(this.updateProjection, !1, !0));\n      }\n      scheduleCheckAfterUnmount() {\n        ie.postRender(() => {\n          this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();\n        });\n      }\n      updateSnapshot() {\n        !this.snapshot && this.instance && (this.snapshot = this.measure());\n      }\n      updateLayout() {\n        if (!this.instance) return;\n        if (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty)) return;\n        if (this.resumeFrom && !this.resumeFrom.instance) for (let t = 0; t < this.path.length; t++) {\n          this.path[t].updateScroll();\n        }\n        const t = this.layout;\n        this.layout = this.measure(!1), this.layoutCorrected = {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        }, this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners(\"measure\", this.layout.layoutBox);\n        const e = this.options.visualElement;\n        e && e.notify(\"LayoutMeasure\", this.layout.layoutBox, t ? t.layoutBox : void 0);\n      }\n      updateScroll() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"measure\";\n        let e = Boolean(this.options.layoutScroll && this.instance);\n        this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e && (this.scroll = {\n          animationId: this.root.animationId,\n          phase: t,\n          isRoot: s(this.instance),\n          offset: n(this.instance)\n        });\n      }\n      resetTransform() {\n        if (!i) return;\n        const t = this.isLayoutDirty || this.shouldResetTransform,\n          e = this.projectionDelta && !Eo(this.projectionDelta),\n          n = this.getTransformTemplate(),\n          s = n ? n(this.latestValues, \"\") : void 0,\n          o = s !== this.prevTransformTemplateValue;\n        t && (e || $i(this.latestValues) || o) && (i(this.instance, s), this.shouldResetTransform = !1, this.scheduleRender());\n      }\n      measure() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n        const e = this.measurePageBox();\n        let n = this.removeElementScroll(e);\n        var s;\n        return t && (n = this.removeTransform(n)), va((s = n).x), va(s.y), {\n          animationId: this.root.animationId,\n          measuredBox: e,\n          layoutBox: n,\n          latestValues: {},\n          source: this.id\n        };\n      }\n      measurePageBox() {\n        const t = this.options.visualElement;\n        if (!t) return {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        };\n        const e = t.measureViewportBox(),\n          n = this.root.scroll;\n        return n && (Ji(e.x, n.offset.x), Ji(e.y, n.offset.y)), e;\n      }\n      removeElementScroll(t) {\n        const e = {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        };\n        xo(e, t);\n        for (let n = 0; n < this.path.length; n++) {\n          const s = this.path[n],\n            i = s.scroll,\n            o = s.options;\n          if (s !== this.root && i && o.layoutScroll) {\n            if (i.isRoot) {\n              xo(e, t);\n              const n = this.root.scroll;\n              n && (Ji(e.x, -n.offset.x), Ji(e.y, -n.offset.y));\n            }\n            Ji(e.x, i.offset.x), Ji(e.y, i.offset.y);\n          }\n        }\n        return e;\n      }\n      applyTransform(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const n = {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        };\n        xo(n, t);\n        for (let t = 0; t < this.path.length; t++) {\n          const s = this.path[t];\n          !e && s.options.layoutScroll && s.scroll && s !== s.root && no(n, {\n            x: -s.scroll.offset.x,\n            y: -s.scroll.offset.y\n          }), $i(s.latestValues) && no(n, s.latestValues);\n        }\n        return $i(this.latestValues) && no(n, this.latestValues), n;\n      }\n      removeTransform(t) {\n        const e = {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        };\n        xo(e, t);\n        for (let t = 0; t < this.path.length; t++) {\n          const n = this.path[t];\n          if (!n.instance) continue;\n          if (!$i(n.latestValues)) continue;\n          Hi(n.latestValues) && n.updateSnapshot();\n          const s = {\n            x: {\n              min: 0,\n              max: 0\n            },\n            y: {\n              min: 0,\n              max: 0\n            }\n          };\n          xo(s, n.measurePageBox()), bo(e, n.latestValues, n.snapshot ? n.snapshot.layoutBox : void 0, s);\n        }\n        return $i(this.latestValues) && bo(e, this.latestValues), e;\n      }\n      setTargetDelta(t) {\n        this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;\n      }\n      setOptions(t) {\n        this.options = _objectSpread(_objectSpread(_objectSpread({}, this.options), t), {}, {\n          crossfade: void 0 === t.crossfade || t.crossfade\n        });\n      }\n      clearMeasurements() {\n        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;\n      }\n      forceRelativeParentToResolveTarget() {\n        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== re.timestamp && this.relativeParent.resolveTargetDelta(!0);\n      }\n      resolveTargetDelta() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        var e;\n        const n = this.getLead();\n        this.isProjectionDirty || (this.isProjectionDirty = n.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = n.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = n.isSharedProjectionDirty);\n        const s = Boolean(this.resumingFrom) || this !== n;\n        if (!(t || s && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty) || this.attemptToResolveRelativeTarget)) return;\n        const _this$options12 = this.options,\n          i = _this$options12.layout,\n          o = _this$options12.layoutId;\n        if (this.layout && (i || o)) {\n          if (this.resolvedRelativeTargetAt = re.timestamp, !this.targetDelta && !this.relativeTarget) {\n            const t = this.getClosestProjectingParent();\n            t && t.layout && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            }, this.relativeTargetOrigin = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            }, Li(this.relativeTargetOrigin, this.layout.layoutBox, t.layout.layoutBox), xo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n          }\n          if (this.relativeTarget || this.targetDelta) {\n            var r, a, l;\n            if (this.target || (this.target = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            }, this.targetWithTransforms = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            }), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), r = this.target, a = this.relativeTarget, l = this.relativeParent.target, Di(r.x, a.x, l.x), Di(r.y, a.y, l.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : xo(this.target, this.layout.layoutBox), qi(this.target, this.targetDelta)) : xo(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {\n              this.attemptToResolveRelativeTarget = !1;\n              const t = this.getClosestProjectingParent();\n              t && Boolean(t.resumingFrom) === Boolean(this.resumingFrom) && !t.options.layoutScroll && t.target && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = {\n                x: {\n                  min: 0,\n                  max: 0\n                },\n                y: {\n                  min: 0,\n                  max: 0\n                }\n              }, this.relativeTargetOrigin = {\n                x: {\n                  min: 0,\n                  max: 0\n                },\n                y: {\n                  min: 0,\n                  max: 0\n                }\n              }, Li(this.relativeTargetOrigin, this.target, t.target), xo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n            }\n            qr.resolvedTargetDeltas++;\n          }\n        }\n      }\n      getClosestProjectingParent() {\n        if (this.parent && !Hi(this.parent.latestValues) && !Yi(this.parent.latestValues)) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();\n      }\n      isProjecting() {\n        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);\n      }\n      calcProjection() {\n        var t;\n        const e = this.getLead(),\n          n = Boolean(this.resumingFrom) || this !== e;\n        let s = !0;\n        if ((this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty)) && (s = !1), n && (this.isSharedProjectionDirty || this.isTransformDirty) && (s = !1), this.resolvedRelativeTargetAt === re.timestamp && (s = !1), s) return;\n        const _this$options13 = this.options,\n          i = _this$options13.layout,\n          o = _this$options13.layoutId;\n        if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !i && !o) return;\n        xo(this.layoutCorrected, this.layout.layoutBox);\n        const r = this.treeScale.x,\n          a = this.treeScale.y;\n        !function (t, e, n) {\n          let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n          const i = n.length;\n          if (!i) return;\n          let o, r;\n          e.x = e.y = 1;\n          for (let a = 0; a < i; a++) {\n            o = n[a], r = o.projectionDelta;\n            const i = o.instance;\n            i && i.style && \"contents\" === i.style.display || (s && o.options.layoutScroll && o.scroll && o !== o.root && no(t, {\n              x: -o.scroll.offset.x,\n              y: -o.scroll.offset.y\n            }), r && (e.x *= r.x.scale, e.y *= r.y.scale, qi(t, r)), s && $i(o.latestValues) && no(t, o.latestValues));\n          }\n          e.x = Zi(e.x), e.y = Zi(e.y);\n        }(this.layoutCorrected, this.treeScale, this.path, n), !e.layout || e.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (e.target = e.layout.layoutBox, e.targetWithTransforms = {\n          x: {\n            min: 0,\n            max: 0\n          },\n          y: {\n            min: 0,\n            max: 0\n          }\n        });\n        const l = e.target;\n        if (!l) return void (this.projectionTransform && (this.projectionDelta = {\n          x: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          },\n          y: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          }\n        }, this.projectionTransform = \"none\", this.scheduleRender()));\n        this.projectionDelta || (this.projectionDelta = {\n          x: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          },\n          y: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          }\n        }, this.projectionDeltaWithTransform = {\n          x: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          },\n          y: {\n            translate: 0,\n            scale: 1,\n            origin: 0,\n            originPoint: 0\n          }\n        });\n        const u = this.projectionTransform;\n        Ri(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.projectionTransform = Ro(this.projectionDelta, this.treeScale), this.projectionTransform === u && this.treeScale.x === r && this.treeScale.y === a || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners(\"projectionUpdate\", l)), qr.recalculatedProjection++;\n      }\n      hide() {\n        this.isVisible = !1;\n      }\n      show() {\n        this.isVisible = !0;\n      }\n      scheduleRender() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n        if (this.options.scheduleRender && this.options.scheduleRender(), t) {\n          const t = this.getStack();\n          t && t.scheduleRender();\n        }\n        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);\n      }\n      setAnimationOrigin(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const n = this.snapshot,\n          s = n ? n.latestValues : {},\n          i = _objectSpread({}, this.latestValues),\n          o = {\n            x: {\n              translate: 0,\n              scale: 1,\n              origin: 0,\n              originPoint: 0\n            },\n            y: {\n              translate: 0,\n              scale: 1,\n              origin: 0,\n              originPoint: 0\n            }\n          };\n        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;\n        const r = {\n            x: {\n              min: 0,\n              max: 0\n            },\n            y: {\n              min: 0,\n              max: 0\n            }\n          },\n          a = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0),\n          l = this.getStack(),\n          u = !l || l.members.length <= 1,\n          c = Boolean(a && !u && !0 === this.options.crossfade && !this.path.some(pa));\n        let h;\n        this.animationProgress = 0, this.mixTargetDelta = e => {\n          const n = e / 1e3;\n          var l, d;\n          da(o.x, t.x, n), da(o.y, t.y, n), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Li(r, this.layout.layoutBox, this.relativeParent.layout.layoutBox), function (t, e, n, s) {\n            ma(t.x, e.x, n.x, s), ma(t.y, e.y, n.y, s);\n          }(this.relativeTarget, this.relativeTargetOrigin, r, n), h && (l = this.relativeTarget, d = h, l.x.min === d.x.min && l.x.max === d.x.max && l.y.min === d.y.min && l.y.max === d.y.max) && (this.isProjectionDirty = !1), h || (h = {\n            x: {\n              min: 0,\n              max: 0\n            },\n            y: {\n              min: 0,\n              max: 0\n            }\n          }), xo(h, this.relativeTarget)), a && (this.animationValues = i, function (t, e, n, s, i, o) {\n            i ? (t.opacity = gs(0, void 0 !== n.opacity ? n.opacity : 1, fo(s)), t.opacityExit = gs(void 0 !== e.opacity ? e.opacity : 1, 0, go(s))) : o && (t.opacity = gs(void 0 !== e.opacity ? e.opacity : 1, void 0 !== n.opacity ? n.opacity : 1, s));\n            for (let i = 0; i < co; i++) {\n              const o = `border${uo[i]}Radius`;\n              let r = po(e, o),\n                a = po(n, o);\n              if (void 0 === r && void 0 === a) continue;\n              r || (r = 0), a || (a = 0);\n              0 === r || 0 === a || mo(r) === mo(a) ? (t[o] = Math.max(gs(ho(r), ho(a), s), 0), (wt.test(a) || wt.test(r)) && (t[o] += \"%\")) : t[o] = a;\n            }\n            (e.rotate || n.rotate) && (t.rotate = gs(e.rotate || 0, n.rotate || 0, s));\n          }(i, s, this.latestValues, n, c, u)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n;\n        }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);\n      }\n      startAnimation(t) {\n        this.notifyListeners(\"animationStart\"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (oe(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ie.update(() => {\n          Lo.hasAnimatedSinceResize = !0, this.currentAnimation = tr(0, 1e3, _objectSpread(_objectSpread({}, t), {}, {\n            onUpdate: e => {\n              this.mixTargetDelta(e), t.onUpdate && t.onUpdate(e);\n            },\n            onComplete: () => {\n              t.onComplete && t.onComplete(), this.completeAnimation();\n            }\n          })), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;\n        });\n      }\n      completeAnimation() {\n        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);\n        const t = this.getStack();\n        t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners(\"animationComplete\");\n      }\n      finishAnimation() {\n        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation();\n      }\n      applyTransformsToTarget() {\n        const t = this.getLead();\n        let e = t.targetWithTransforms,\n          n = t.target,\n          s = t.layout,\n          i = t.latestValues;\n        if (e && n && s) {\n          if (this !== t && this.layout && s && xa(this.options.animationType, this.layout.layoutBox, s.layoutBox)) {\n            n = this.target || {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            };\n            const e = Ci(this.layout.layoutBox.x);\n            n.x.min = t.target.x.min, n.x.max = n.x.min + e;\n            const s = Ci(this.layout.layoutBox.y);\n            n.y.min = t.target.y.min, n.y.max = n.y.min + s;\n          }\n          xo(e, n), no(e, i), Ri(this.projectionDeltaWithTransform, this.layoutCorrected, e, i);\n        }\n      }\n      registerSharedNode(t, e) {\n        this.sharedNodes.has(t) || this.sharedNodes.set(t, new Mo());\n        this.sharedNodes.get(t).add(e);\n        const n = e.options.initialPromotionConfig;\n        e.promote({\n          transition: n ? n.transition : void 0,\n          preserveFollowOpacity: n && n.shouldPreserveFollowOpacity ? n.shouldPreserveFollowOpacity(e) : void 0\n        });\n      }\n      isLead() {\n        const t = this.getStack();\n        return !t || t.lead === this;\n      }\n      getLead() {\n        var t;\n        const e = this.options.layoutId;\n        return e && (null === (t = this.getStack()) || void 0 === t ? void 0 : t.lead) || this;\n      }\n      getPrevLead() {\n        var t;\n        const e = this.options.layoutId;\n        return e ? null === (t = this.getStack()) || void 0 === t ? void 0 : t.prevLead : void 0;\n      }\n      getStack() {\n        const t = this.options.layoutId;\n        if (t) return this.root.sharedNodes.get(t);\n      }\n      promote() {\n        let _ref94 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          t = _ref94.needsReset,\n          e = _ref94.transition,\n          n = _ref94.preserveFollowOpacity;\n        const s = this.getStack();\n        s && s.promote(this, n), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({\n          transition: e\n        });\n      }\n      relegate() {\n        const t = this.getStack();\n        return !!t && t.relegate(this);\n      }\n      resetSkewAndRotation() {\n        const t = this.options.visualElement;\n        if (!t) return;\n        let e = !1;\n        const n = t.latestValues;\n        if ((n.z || n.rotate || n.rotateX || n.rotateY || n.rotateZ || n.skewX || n.skewY) && (e = !0), !e) return;\n        const s = {};\n        n.z && Zr(\"z\", t, s, this.animationValues);\n        for (let e = 0; e < Kr.length; e++) Zr(\"rotate\" + Kr[e], t, s, this.animationValues), Zr(\"skew\" + Kr[e], t, s, this.animationValues);\n        t.render();\n        for (const e in s) t.setStaticValue(e, s[e]), this.animationValues && (this.animationValues[e] = s[e]);\n        t.scheduleRender();\n      }\n      getProjectionStyles(t) {\n        var e, n;\n        if (!this.instance || this.isSVG) return;\n        if (!this.isVisible) return Gr;\n        const s = {\n            visibility: \"\"\n          },\n          i = this.getTransformTemplate();\n        if (this.needsReset) return this.needsReset = !1, s.opacity = \"\", s.pointerEvents = te(null == t ? void 0 : t.pointerEvents) || \"\", s.transform = i ? i(this.latestValues, \"\") : \"none\", s;\n        const o = this.getLead();\n        if (!this.projectionDelta || !this.layout || !o.target) {\n          const e = {};\n          return this.options.layoutId && (e.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e.pointerEvents = te(null == t ? void 0 : t.pointerEvents) || \"\"), this.hasProjected && !$i(this.latestValues) && (e.transform = i ? i({}, \"\") : \"none\", this.hasProjected = !1), e;\n        }\n        const r = o.animationValues || o.latestValues;\n        this.applyTransformsToTarget(), s.transform = Ro(this.projectionDeltaWithTransform, this.treeScale, r), i && (s.transform = i(r, s.transform));\n        const _this$projectionDelta = this.projectionDelta,\n          a = _this$projectionDelta.x,\n          l = _this$projectionDelta.y;\n        s.transformOrigin = `${100 * a.origin}% ${100 * l.origin}% 0`, o.animationValues ? s.opacity = o === this ? null !== (n = null !== (e = r.opacity) && void 0 !== e ? e : this.latestValues.opacity) && void 0 !== n ? n : 1 : this.preserveOpacity ? this.latestValues.opacity : r.opacityExit : s.opacity = o === this ? void 0 !== r.opacity ? r.opacity : \"\" : void 0 !== r.opacityExit ? r.opacityExit : 0;\n        for (const t in _) {\n          if (void 0 === r[t]) continue;\n          const _$t = _[t],\n            e = _$t.correct,\n            n = _$t.applyTo,\n            i = \"none\" === s.transform ? r[t] : e(r[t], o);\n          if (n) {\n            const t = n.length;\n            for (let e = 0; e < t; e++) s[n[e]] = i;\n          } else s[t] = i;\n        }\n        return this.options.layoutId && (s.pointerEvents = o === this ? te(null == t ? void 0 : t.pointerEvents) || \"\" : \"none\"), s;\n      }\n      clearSnapshot() {\n        this.resumeFrom = this.snapshot = void 0;\n      }\n      resetTree() {\n        this.root.nodes.forEach(t => {\n          var e;\n          return null === (e = t.currentAnimation) || void 0 === e ? void 0 : e.stop();\n        }), this.root.nodes.forEach(ia), this.root.sharedNodes.clear();\n      }\n    };\n  }\n  function Qr(t) {\n    t.updateLayout();\n  }\n  function ta(t) {\n    var e;\n    const n = (null === (e = t.resumeFrom) || void 0 === e ? void 0 : e.snapshot) || t.snapshot;\n    if (t.isLead() && t.layout && n && t.hasListeners(\"didUpdate\")) {\n      const _t$layout = t.layout,\n        e = _t$layout.layoutBox,\n        s = _t$layout.measuredBox,\n        i = t.options.animationType,\n        o = n.source !== t.layout.source;\n      \"size\" === i ? Wi(t => {\n        const s = o ? n.measuredBox[t] : n.layoutBox[t],\n          i = Ci(s);\n        s.min = e[t].min, s.max = s.min + i;\n      }) : xa(i, n.layoutBox, e) && Wi(s => {\n        const i = o ? n.measuredBox[s] : n.layoutBox[s],\n          r = Ci(e[s]);\n        i.max = i.min + r, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[s].max = t.relativeTarget[s].min + r);\n      });\n      const r = {\n        x: {\n          translate: 0,\n          scale: 1,\n          origin: 0,\n          originPoint: 0\n        },\n        y: {\n          translate: 0,\n          scale: 1,\n          origin: 0,\n          originPoint: 0\n        }\n      };\n      Ri(r, e, n.layoutBox);\n      const a = {\n        x: {\n          translate: 0,\n          scale: 1,\n          origin: 0,\n          originPoint: 0\n        },\n        y: {\n          translate: 0,\n          scale: 1,\n          origin: 0,\n          originPoint: 0\n        }\n      };\n      o ? Ri(a, t.applyTransform(s, !0), n.measuredBox) : Ri(a, e, n.layoutBox);\n      const l = !Eo(r);\n      let u = !1;\n      if (!t.resumeFrom) {\n        const s = t.getClosestProjectingParent();\n        if (s && !s.resumeFrom) {\n          const i = s.snapshot,\n            o = s.layout;\n          if (i && o) {\n            const r = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            };\n            Li(r, n.layoutBox, i.layoutBox);\n            const a = {\n              x: {\n                min: 0,\n                max: 0\n              },\n              y: {\n                min: 0,\n                max: 0\n              }\n            };\n            Li(a, e, o.layoutBox), Co(r, a) || (u = !0), s.options.layoutRoot && (t.relativeTarget = a, t.relativeTargetOrigin = r, t.relativeParent = s);\n          }\n        }\n      }\n      t.notifyListeners(\"didUpdate\", {\n        layout: e,\n        snapshot: n,\n        delta: a,\n        layoutDelta: r,\n        hasLayoutChanged: l,\n        hasRelativeTargetChanged: u\n      });\n    } else if (t.isLead()) {\n      const e = t.options.onExitComplete;\n      e && e();\n    }\n    t.options.transition = void 0;\n  }\n  function ea(t) {\n    qr.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = Boolean(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));\n  }\n  function na(t) {\n    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;\n  }\n  function sa(t) {\n    t.clearSnapshot();\n  }\n  function ia(t) {\n    t.clearMeasurements();\n  }\n  function oa(t) {\n    t.isLayoutDirty = !1;\n  }\n  function ra(t) {\n    const e = t.options.visualElement;\n    e && e.getProps().onBeforeLayoutMeasure && e.notify(\"BeforeLayoutMeasure\"), t.resetTransform();\n  }\n  function aa(t) {\n    t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;\n  }\n  function la(t) {\n    t.resolveTargetDelta();\n  }\n  function ua(t) {\n    t.calcProjection();\n  }\n  function ca(t) {\n    t.resetSkewAndRotation();\n  }\n  function ha(t) {\n    t.removeLeadSnapshot();\n  }\n  function da(t, e, n) {\n    t.translate = gs(e.translate, 0, n), t.scale = gs(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;\n  }\n  function ma(t, e, n, s) {\n    t.min = gs(e.min, n.min, s), t.max = gs(e.max, n.max, s);\n  }\n  function pa(t) {\n    return t.animationValues && void 0 !== t.animationValues.opacityExit;\n  }\n  const fa = {\n      duration: .45,\n      ease: [.4, 0, .1, 1]\n    },\n    ga = t => \"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t),\n    ya = ga(\"applewebkit/\") && !ga(\"chrome/\") ? Math.round : se;\n  function va(t) {\n    t.min = ya(t.min), t.max = ya(t.max);\n  }\n  function xa(t, e, n) {\n    return \"position\" === t || \"preserve-aspect\" === t && !Vi(Vo(e), Vo(n), .2);\n  }\n  const Pa = Jr({\n      attachResizeListener: (t, e) => he(t, \"resize\", e),\n      measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop\n      }),\n      checkIsScrollRoot: () => !0\n    }),\n    wa = {\n      current: void 0\n    },\n    Ta = Jr({\n      measureScroll: t => ({\n        x: t.scrollLeft,\n        y: t.scrollTop\n      }),\n      defaultParent: () => {\n        if (!wa.current) {\n          const t = new Pa({});\n          t.mount(window), t.setOptions({\n            layoutScroll: !0\n          }), wa.current = t;\n        }\n        return wa.current;\n      },\n      resetTransform: (t, e) => {\n        t.style.transform = void 0 !== e ? e : \"none\";\n      },\n      checkIsScrollRoot: t => Boolean(\"fixed\" === window.getComputedStyle(t).position)\n    }),\n    Sa = t => !t.isLayoutDirty && t.willUpdate(!1);\n  function ba() {\n    const t = new Set(),\n      e = new WeakMap(),\n      n = () => t.forEach(Sa);\n    return {\n      add: s => {\n        t.add(s), e.set(s, s.addEventListener(\"willUpdate\", n));\n      },\n      remove: s => {\n        t.delete(s);\n        const i = e.get(s);\n        i && (i(), e.delete(s)), n();\n      },\n      dirty: n\n    };\n  }\n  function Aa(t, e) {\n    return e.max === e.min ? 0 : t / (e.max - e.min) * 100;\n  }\n  const Ea = {\n      correct: (t, e) => {\n        if (!e.target) return t;\n        if (\"string\" == typeof t) {\n          if (!Tt.test(t)) return t;\n          t = parseFloat(t);\n        }\n        return `${Aa(t, e.target.x)}% ${Aa(t, e.target.y)}%`;\n      }\n    },\n    Ca = {\n      correct: (t, _ref95) => {\n        let e = _ref95.treeScale,\n          n = _ref95.projectionDelta;\n        const s = t,\n          i = Rn.parse(t);\n        if (i.length > 5) return s;\n        const o = Rn.createTransformer(t),\n          r = \"number\" != typeof i[0] ? 1 : 0,\n          a = n.x.scale * e.x,\n          l = n.y.scale * e.y;\n        i[0 + r] /= a, i[1 + r] /= l;\n        const u = gs(a, l, .5);\n        return \"number\" == typeof i[2 + r] && (i[2 + r] /= u), \"number\" == typeof i[3 + r] && (i[3 + r] /= u), o(i);\n      }\n    };\n  function Va() {\n    const t = e.useContext(g);\n    if (null === t) return [!0, null];\n    const n = t.isPresent,\n      s = t.onExitComplete,\n      i = t.register,\n      o = e.useId();\n    e.useEffect(() => i(o), []);\n    return !n && s ? [!1, () => s && s(o)] : [!0];\n  }\n  class Ma extends e.Component {\n    componentDidMount() {\n      const _this$props = this.props,\n        t = _this$props.visualElement,\n        e = _this$props.layoutGroup,\n        n = _this$props.switchLayoutGroup,\n        s = _this$props.layoutId,\n        i = t.projection;\n      q(Da), i && (e.group && e.group.add(i), n && n.register && s && n.register(i), i.root.didUpdate(), i.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      }), i.setOptions(_objectSpread(_objectSpread({}, i.options), {}, {\n        onExitComplete: () => this.safeToRemove()\n      }))), Lo.hasEverUpdated = !0;\n    }\n    getSnapshotBeforeUpdate(t) {\n      const _this$props2 = this.props,\n        e = _this$props2.layoutDependency,\n        n = _this$props2.visualElement,\n        s = _this$props2.drag,\n        i = _this$props2.isPresent,\n        o = n.projection;\n      return o ? (o.isPresent = i, s || t.layoutDependency !== e || void 0 === e ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || ie.postRender(() => {\n        const t = o.getStack();\n        t && t.members.length || this.safeToRemove();\n      })), null) : null;\n    }\n    componentDidUpdate() {\n      const t = this.props.visualElement.projection;\n      t && (t.root.didUpdate(), E.postRender(() => {\n        !t.currentAnimation && t.isLead() && this.safeToRemove();\n      }));\n    }\n    componentWillUnmount() {\n      const _this$props3 = this.props,\n        t = _this$props3.visualElement,\n        e = _this$props3.layoutGroup,\n        n = _this$props3.switchLayoutGroup,\n        s = t.projection;\n      s && (s.scheduleCheckAfterUnmount(), e && e.group && e.group.remove(s), n && n.deregister && n.deregister(s));\n    }\n    safeToRemove() {\n      const t = this.props.safeToRemove;\n      t && t();\n    }\n    render() {\n      return null;\n    }\n  }\n  function Ra(t) {\n    const _Va = Va(),\n      _Va2 = _slicedToArray(_Va, 2),\n      n = _Va2[0],\n      s = _Va2[1],\n      i = e.useContext(N);\n    return d(Ma, _objectSpread(_objectSpread({}, t), {}, {\n      layoutGroup: i,\n      switchLayoutGroup: e.useContext(z),\n      isPresent: n,\n      safeToRemove: s\n    }));\n  }\n  const Da = {\n      borderRadius: _objectSpread(_objectSpread({}, Ea), {}, {\n        applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n      }),\n      borderTopLeftRadius: Ea,\n      borderTopRightRadius: Ea,\n      borderBottomLeftRadius: Ea,\n      borderBottomRightRadius: Ea,\n      boxShadow: Ca\n    },\n    ka = {\n      pan: {\n        Feature: class extends Se {\n          constructor() {\n            super(...arguments), this.removePointerDownListener = se;\n          }\n          onPointerDown(t) {\n            this.session = new Pi(t, this.createPanHandlers(), {\n              transformPagePoint: this.node.getTransformPagePoint(),\n              contextWindow: io(this.node)\n            });\n          }\n          createPanHandlers() {\n            const _this$node$getProps9 = this.node.getProps(),\n              t = _this$node$getProps9.onPanSessionStart,\n              e = _this$node$getProps9.onPanStart,\n              n = _this$node$getProps9.onPan,\n              s = _this$node$getProps9.onPanEnd;\n            return {\n              onSessionStart: lo(t),\n              onStart: lo(e),\n              onMove: n,\n              onEnd: (t, e) => {\n                delete this.session, s && ie.postRender(() => s(t, e));\n              }\n            };\n          }\n          mount() {\n            this.removePointerDownListener = fe(this.node.current, \"pointerdown\", t => this.onPointerDown(t));\n          }\n          update() {\n            this.session && this.session.updateHandlers(this.createPanHandlers());\n          }\n          unmount() {\n            this.removePointerDownListener(), this.session && this.session.end();\n          }\n        }\n      },\n      drag: {\n        Feature: class extends Se {\n          constructor(t) {\n            super(t), this.removeGroupControls = se, this.removeListeners = se, this.controls = new ro(t);\n          }\n          mount() {\n            const _this$node$getProps10 = this.node.getProps(),\n              t = _this$node$getProps10.dragControls;\n            t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || se;\n          }\n          unmount() {\n            this.removeGroupControls(), this.removeListeners();\n          }\n        },\n        ProjectionNode: Ta,\n        MeasureLayout: Ra\n      }\n    },\n    La = (t, n) => G(t) ? new Zo(n, {\n      enableHardwareAcceleration: !1\n    }) : new Jo(n, {\n      allowProjection: t !== e.Fragment,\n      enableHardwareAcceleration: !0\n    }),\n    Ba = {\n      layout: {\n        ProjectionNode: Ta,\n        MeasureLayout: Ra\n      }\n    },\n    Fa = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, yi), Le), ka), Ba),\n    ja = X((t, e) => ce(t, e, Fa, La));\n  const Oa = X(ce);\n  function Ia() {\n    const t = e.useRef(!1);\n    return v(() => (t.current = !0, () => {\n      t.current = !1;\n    }), []), t;\n  }\n  function Ua() {\n    const t = Ia(),\n      _e$useState = e.useState(0),\n      _e$useState2 = _slicedToArray(_e$useState, 2),\n      n = _e$useState2[0],\n      s = _e$useState2[1],\n      i = e.useCallback(() => {\n        t.current && s(n + 1);\n      }, [n]);\n    return [e.useCallback(() => ie.postRender(i), [i]), n];\n  }\n  class Wa extends s.Component {\n    getSnapshotBeforeUpdate(t) {\n      const e = this.props.childRef.current;\n      if (e && t.isPresent && !this.props.isPresent) {\n        const t = this.props.sizeRef.current;\n        t.height = e.offsetHeight || 0, t.width = e.offsetWidth || 0, t.top = e.offsetTop, t.left = e.offsetLeft;\n      }\n      return null;\n    }\n    componentDidUpdate() {}\n    render() {\n      return this.props.children;\n    }\n  }\n  function Na(_ref96) {\n    let t = _ref96.children,\n      n = _ref96.isPresent;\n    const i = e.useId(),\n      o = e.useRef(null),\n      r = e.useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n      }),\n      _e$useContext2 = e.useContext(p),\n      a = _e$useContext2.nonce;\n    return e.useInsertionEffect(() => {\n      const _r$current = r.current,\n        t = _r$current.width,\n        e = _r$current.height,\n        s = _r$current.top,\n        l = _r$current.left;\n      if (n || !o.current || !t || !e) return;\n      o.current.dataset.motionPopId = i;\n      const u = document.createElement(\"style\");\n      return a && (u.nonce = a), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`\\n          [data-motion-pop-id=\"${i}\"] {\\n            position: absolute !important;\\n            width: ${t}px !important;\\n            height: ${e}px !important;\\n            top: ${s}px !important;\\n            left: ${l}px !important;\\n          }\\n        `), () => {\n        document.head.removeChild(u);\n      };\n    }, [n]), d(Wa, {\n      isPresent: n,\n      childRef: o,\n      sizeRef: r,\n      children: s.cloneElement(t, {\n        ref: o\n      })\n    });\n  }\n  const za = _ref97 => {\n    let t = _ref97.children,\n      n = _ref97.initial,\n      i = _ref97.isPresent,\n      o = _ref97.onExitComplete,\n      r = _ref97.custom,\n      a = _ref97.presenceAffectsLayout,\n      l = _ref97.mode;\n    const u = Jt(Ha),\n      c = e.useId(),\n      h = e.useMemo(() => ({\n        id: c,\n        initial: n,\n        isPresent: i,\n        custom: r,\n        onExitComplete: t => {\n          u.set(t, !0);\n          for (const t of u.values()) if (!t) return;\n          o && o();\n        },\n        register: t => (u.set(t, !1), () => u.delete(t))\n      }), a ? [Math.random()] : [i]);\n    return e.useMemo(() => {\n      u.forEach((t, e) => u.set(e, !1));\n    }, [i]), s.useEffect(() => {\n      !i && !u.size && o && o();\n    }, [i]), \"popLayout\" === l && (t = d(Na, {\n      isPresent: i,\n      children: t\n    })), d(g.Provider, {\n      value: h,\n      children: t\n    });\n  };\n  function Ha() {\n    return new Map();\n  }\n  function $a(t) {\n    return e.useEffect(() => () => t(), []);\n  }\n  const Ya = t => t.key || \"\";\n  function Xa(t) {\n    return \"function\" == typeof t;\n  }\n  const Ka = e.createContext(null),\n    Ga = t => !0 === t,\n    _a = _ref98 => {\n      let t = _ref98.children,\n        n = _ref98.id,\n        _ref98$inherit = _ref98.inherit,\n        s = _ref98$inherit === void 0 ? !0 : _ref98$inherit;\n      const i = e.useContext(N),\n        o = e.useContext(Ka),\n        _Ua = Ua(),\n        _Ua2 = _slicedToArray(_Ua, 2),\n        r = _Ua2[0],\n        a = _Ua2[1],\n        l = e.useRef(null),\n        u = i.id || o;\n      null === l.current && ((t => Ga(!0 === t) || \"id\" === t)(s) && u && (n = n ? u + \"-\" + n : u), l.current = {\n        id: n,\n        group: Ga(s) && i.group || ba()\n      });\n      const c = e.useMemo(() => _objectSpread(_objectSpread({}, l.current), {}, {\n        forceRender: r\n      }), [a]);\n      return d(N.Provider, {\n        value: c,\n        children: t\n      });\n    },\n    qa = e.createContext(null);\n  function Za(t) {\n    return t.value;\n  }\n  function Ja(t, e) {\n    return t.layout.min - e.layout.min;\n  }\n  function Qa(t) {\n    const n = Jt(() => si(t)),\n      _e$useContext3 = e.useContext(p),\n      s = _e$useContext3.isStatic;\n    if (s) {\n      const _e$useState3 = e.useState(t),\n        _e$useState4 = _slicedToArray(_e$useState3, 2),\n        s = _e$useState4[1];\n      e.useEffect(() => n.on(\"change\", s), []);\n    }\n    return n;\n  }\n  function tl(t, e) {\n    const n = Qa(e()),\n      s = () => n.set(e());\n    return s(), v(() => {\n      const e = () => ie.preRender(s, !1, !0),\n        n = t.map(t => t.on(\"change\", e));\n      return () => {\n        n.forEach(t => t()), oe(s);\n      };\n    }), n;\n  }\n  function el(t, e, n, s) {\n    if (\"function\" == typeof t) return function (t) {\n      ei.current = [], t();\n      const e = tl(ei.current, t);\n      return ei.current = void 0, e;\n    }(t);\n    const i = \"function\" == typeof e ? e : $r(e, n, s);\n    return Array.isArray(t) ? nl(t, i) : nl([t], _ref99 => {\n      let _ref100 = _slicedToArray(_ref99, 1),\n        t = _ref100[0];\n      return i(t);\n    });\n  }\n  function nl(t, e) {\n    const n = Jt(() => []);\n    return tl(t, () => {\n      n.length = 0;\n      const s = t.length;\n      for (let e = 0; e < s; e++) n[e] = t[e].get();\n      return e(n);\n    });\n  }\n  function sl(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return tt(t) ? t : Qa(e);\n  }\n  const il = {\n      Group: e.forwardRef(function (_ref101, a) {\n        let t = _ref101.children,\n          _ref101$as = _ref101.as,\n          n = _ref101$as === void 0 ? \"ul\" : _ref101$as,\n          _ref101$axis = _ref101.axis,\n          s = _ref101$axis === void 0 ? \"y\" : _ref101$axis,\n          i = _ref101.onReorder,\n          o = _ref101.values,\n          r = _objectWithoutProperties(_ref101, _excluded18);\n        const l = Jt(() => ja(n)),\n          u = [],\n          c = e.useRef(!1),\n          h = {\n            axis: s,\n            registerItem: (t, e) => {\n              const n = u.findIndex(e => t === e.value);\n              -1 !== n ? u[n].layout = e[s] : u.push({\n                value: t,\n                layout: e[s]\n              }), u.sort(Ja);\n            },\n            updateOrder: (t, e, n) => {\n              if (c.current) return;\n              const s = function (t, e, n, s) {\n                if (!s) return t;\n                const i = t.findIndex(t => t.value === e);\n                if (-1 === i) return t;\n                const o = s > 0 ? 1 : -1,\n                  r = t[i + o];\n                if (!r) return t;\n                const a = t[i],\n                  l = r.layout,\n                  u = gs(l.min, l.max, .5);\n                return 1 === o && a.layout.max + n > u || -1 === o && a.layout.min + n < u ? function (_ref102, e, n) {\n                  let _ref103 = _toArray(_ref102),\n                    t = _ref103.slice(0);\n                  const s = e < 0 ? t.length + e : e;\n                  if (s >= 0 && s < t.length) {\n                    const s = n < 0 ? t.length + n : n,\n                      _t$splice = t.splice(e, 1),\n                      _t$splice2 = _slicedToArray(_t$splice, 1),\n                      i = _t$splice2[0];\n                    t.splice(s, 0, i);\n                  }\n                  return t;\n                }(t, i, i + o) : t;\n              }(u, t, e, n);\n              u !== s && (c.current = !0, i(s.map(Za).filter(t => -1 !== o.indexOf(t))));\n            }\n          };\n        return e.useEffect(() => {\n          c.current = !1;\n        }), d(l, _objectSpread(_objectSpread({}, r), {}, {\n          ref: a,\n          ignoreStrict: !0,\n          children: d(qa.Provider, {\n            value: h,\n            children: t\n          })\n        }));\n      }),\n      Item: e.forwardRef(function (_ref104, l) {\n        let t = _ref104.children,\n          _ref104$style = _ref104.style,\n          n = _ref104$style === void 0 ? {} : _ref104$style,\n          s = _ref104.value,\n          _ref104$as = _ref104.as,\n          i = _ref104$as === void 0 ? \"li\" : _ref104$as,\n          o = _ref104.onDrag,\n          _ref104$layout = _ref104.layout,\n          r = _ref104$layout === void 0 ? !0 : _ref104$layout,\n          a = _objectWithoutProperties(_ref104, _excluded19);\n        const u = Jt(() => ja(i)),\n          c = e.useContext(qa),\n          h = {\n            x: sl(n.x),\n            y: sl(n.y)\n          },\n          m = el([h.x, h.y], _ref105 => {\n            let _ref106 = _slicedToArray(_ref105, 2),\n              t = _ref106[0],\n              e = _ref106[1];\n            return t || e ? 1 : \"unset\";\n          }),\n          p = c.axis,\n          f = c.registerItem,\n          g = c.updateOrder;\n        return d(u, _objectSpread(_objectSpread({\n          drag: p\n        }, a), {}, {\n          dragSnapToOrigin: !0,\n          style: _objectSpread(_objectSpread({}, n), {}, {\n            x: h.x,\n            y: h.y,\n            zIndex: m\n          }),\n          layout: r,\n          onDrag: (t, e) => {\n            const n = e.velocity;\n            n[p] && g(s, h[p].get(), n[p]), o && o(t, e);\n          },\n          onLayoutMeasure: t => f(s, t),\n          ref: l,\n          ignoreStrict: !0,\n          children: t\n        }));\n      })\n    },\n    ol = _objectSpread(_objectSpread({\n      renderer: La\n    }, yi), Le),\n    rl = _objectSpread(_objectSpread(_objectSpread({}, ol), ka), Ba);\n  function al(t, n, s) {\n    e.useInsertionEffect(() => t.on(n, s), [t, n, s]);\n  }\n  function ll(t, e) {\n    qe(Boolean(!e || e.current));\n  }\n  const ul = () => ({\n    scrollX: si(0),\n    scrollY: si(0),\n    scrollXProgress: si(0),\n    scrollYProgress: si(0)\n  });\n  function cl() {\n    let _ref107 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let t = _ref107.container,\n      n = _ref107.target,\n      _ref107$layoutEffect = _ref107.layoutEffect,\n      s = _ref107$layoutEffect === void 0 ? !0 : _ref107$layoutEffect,\n      i = _objectWithoutProperties(_ref107, _excluded20);\n    const o = Jt(ul);\n    return (s ? v : e.useEffect)(() => (ll(0, n), ll(0, t), Ur(_ref108 => {\n      let t = _ref108.x,\n        e = _ref108.y;\n      o.scrollX.set(t.current), o.scrollXProgress.set(t.progress), o.scrollY.set(e.current), o.scrollYProgress.set(e.progress);\n    }, _objectSpread(_objectSpread({}, i), {}, {\n      container: (null == t ? void 0 : t.current) || void 0,\n      target: (null == n ? void 0 : n.current) || void 0\n    }))), [t, n, JSON.stringify(i.offset)]), o;\n  }\n  function hl(t) {\n    const n = e.useRef(0),\n      _e$useContext4 = e.useContext(p),\n      s = _e$useContext4.isStatic;\n    e.useEffect(() => {\n      if (s) return;\n      const e = _ref109 => {\n        let e = _ref109.timestamp,\n          s = _ref109.delta;\n        n.current || (n.current = e), t(e - n.current, s);\n      };\n      return ie.update(e, !0), () => oe(e);\n    }, [t]);\n  }\n  class dl extends ni {\n    constructor() {\n      super(...arguments), this.members = [], this.transforms = new Set();\n    }\n    add(t) {\n      let e;\n      J.has(t) ? (this.transforms.add(t), e = \"transform\") : t.startsWith(\"origin\") || ot(t) || \"willChange\" === t || (e = P(t)), e && (Js(this.members, e), this.update());\n    }\n    remove(t) {\n      J.has(t) ? (this.transforms.delete(t), this.transforms.size || Qs(this.members, \"transform\")) : Qs(this.members, P(t)), this.update();\n    }\n    update() {\n      this.set(this.members.length ? this.members.join(\", \") : \"auto\");\n    }\n  }\n  function ml() {\n    !zo.current && Ho();\n    const _e$useState5 = e.useState(No.current),\n      _e$useState6 = _slicedToArray(_e$useState5, 1),\n      t = _e$useState6[0];\n    return t;\n  }\n  function pl(t, e) {\n    [...e].reverse().forEach(n => {\n      const s = t.getVariant(n);\n      s && oi(t, s), t.variantChildren && t.variantChildren.forEach(t => {\n        pl(t, e);\n      });\n    });\n  }\n  function fl() {\n    const t = new Set(),\n      e = {\n        subscribe: e => (t.add(e), () => {\n          t.delete(e);\n        }),\n        start(e, n) {\n          const s = [];\n          return t.forEach(t => {\n            s.push(ci(t, e, {\n              transitionOverride: n\n            }));\n          }), Promise.all(s);\n        },\n        set: e => t.forEach(t => {\n          !function (t, e) {\n            Array.isArray(e) ? pl(t, e) : \"string\" == typeof e ? pl(t, [e]) : oi(t, e);\n          }(t, e);\n        }),\n        stop() {\n          t.forEach(t => {\n            !function (t) {\n              t.values.forEach(t => t.stop());\n            }(t);\n          });\n        },\n        mount: () => () => {\n          e.stop();\n        }\n      };\n    return e;\n  }\n  function gl() {\n    const t = Jt(fl);\n    return v(t.mount, []), t;\n  }\n  const yl = gl;\n  class vl {\n    constructor() {\n      this.componentControls = new Set();\n    }\n    subscribe(t) {\n      return this.componentControls.add(t), () => this.componentControls.delete(t);\n    }\n    start(t, e) {\n      this.componentControls.forEach(n => {\n        n.start(t.nativeEvent || t, e);\n      });\n    }\n  }\n  const xl = () => new vl();\n  function Pl(t) {\n    return null !== t && \"object\" == typeof t && H in t;\n  }\n  function wl() {\n    return Tl;\n  }\n  function Tl(t) {\n    wa.current && (wa.current.isUpdating = !1, wa.current.blockUpdate(), t && t());\n  }\n  const Sl = (t, e) => `${t}: ${e}`,\n    bl = new Map();\n  let Al, El, Cl;\n  function Vl(t, e, n, s) {\n    const i = J.has(e) ? \"transform\" : e,\n      o = Sl(t, i),\n      r = bl.get(o);\n    if (!r) return null;\n    const a = r.animation,\n      l = r.startTime;\n    return null === l || window.HandoffComplete ? ((() => {\n      bl.delete(o);\n      try {\n        a.cancel();\n      } catch (t) {}\n    })(), null) : (void 0 === Al && (Al = performance.now()), Al - l || 0);\n  }\n  const Ml = () => ({});\n  class Rl extends _o {\n    build() {}\n    measureInstanceViewportBox() {\n      return {\n        x: {\n          min: 0,\n          max: 0\n        },\n        y: {\n          min: 0,\n          max: 0\n        }\n      };\n    }\n    resetTransform() {}\n    restoreTransform() {}\n    removeValueFromRenderState() {}\n    renderInstance() {}\n    scrapeMotionValuesFromProps() {\n      return {};\n    }\n    getBaseTargetFromProps() {}\n    readValueFromInstance(t, e, n) {\n      return n.initialState[e] || 0;\n    }\n    sortInstanceNodePosition() {\n      return 0;\n    }\n  }\n  const Dl = ee({\n    scrapeMotionValuesFromProps: Ml,\n    createRenderState: Ml\n  });\n  const kl = t => t > .001 ? 1 / t : 1e5;\n  let Ll = 0;\n  t.AcceleratedAnimation = _s, t.AnimatePresence = _ref110 => {\n    let t = _ref110.children,\n      n = _ref110.custom,\n      _ref110$initial = _ref110.initial,\n      s = _ref110$initial === void 0 ? !0 : _ref110$initial,\n      i = _ref110.onExitComplete,\n      o = _ref110.exitBeforeEnter,\n      _ref110$presenceAffec = _ref110.presenceAffectsLayout,\n      r = _ref110$presenceAffec === void 0 ? !0 : _ref110$presenceAffec,\n      _ref110$mode = _ref110.mode,\n      a = _ref110$mode === void 0 ? \"sync\" : _ref110$mode;\n    const l = e.useContext(N).forceRender || Ua()[0],\n      u = Ia(),\n      c = function (t) {\n        const n = [];\n        return e.Children.forEach(t, t => {\n          e.isValidElement(t) && n.push(t);\n        }), n;\n      }(t);\n    let m = c;\n    const p = e.useRef(new Map()).current,\n      f = e.useRef(m),\n      g = e.useRef(new Map()).current,\n      y = e.useRef(!0);\n    if (v(() => {\n      y.current = !1, function (t, e) {\n        t.forEach(t => {\n          const n = Ya(t);\n          e.set(n, t);\n        });\n      }(c, g), f.current = m;\n    }), $a(() => {\n      y.current = !0, g.clear(), p.clear();\n    }), y.current) return d(h, {\n      children: m.map(t => d(za, {\n        isPresent: !0,\n        initial: !!s && void 0,\n        presenceAffectsLayout: r,\n        mode: a,\n        children: t\n      }, Ya(t)))\n    });\n    m = [...m];\n    const x = f.current.map(Ya),\n      P = c.map(Ya),\n      w = x.length;\n    for (let t = 0; t < w; t++) {\n      const e = x[t];\n      -1 !== P.indexOf(e) || p.has(e) || p.set(e, void 0);\n    }\n    return \"wait\" === a && p.size && (m = []), p.forEach((t, e) => {\n      if (-1 !== P.indexOf(e)) return;\n      const s = g.get(e);\n      if (!s) return;\n      const o = x.indexOf(e);\n      let h = t;\n      if (!h) {\n        h = d(za, {\n          isPresent: !1,\n          onExitComplete: () => {\n            p.delete(e);\n            const t = Array.from(g.keys()).filter(t => !P.includes(t));\n            if (t.forEach(t => g.delete(t)), f.current = c.filter(n => {\n              const s = Ya(n);\n              return s === e || t.includes(s);\n            }), !p.size) {\n              if (!1 === u.current) return;\n              l(), i && i();\n            }\n          },\n          custom: n,\n          presenceAffectsLayout: r,\n          mode: a,\n          children: s\n        }, Ya(s)), p.set(e, h);\n      }\n      m.splice(o, 0, h);\n    }), m = m.map(t => {\n      const e = t.key;\n      return p.has(e) ? t : d(za, {\n        isPresent: !0,\n        presenceAffectsLayout: r,\n        mode: a,\n        children: t\n      }, Ya(t));\n    }), d(h, {\n      children: p.size ? m : m.map(t => e.cloneElement(t))\n    });\n  }, t.AnimateSharedLayout = _ref111 => {\n    let t = _ref111.children;\n    return s.useEffect(() => {}, []), d(_a, {\n      id: Jt(() => \"asl-\" + Ll++),\n      children: t\n    });\n  }, t.DeprecatedLayoutGroupContext = Ka, t.DragControls = vl, t.FlatTree = ko, t.LayoutGroup = _a, t.LayoutGroupContext = N, t.LazyMotion = function (_ref112) {\n    let t = _ref112.children,\n      n = _ref112.features,\n      _ref112$strict = _ref112.strict,\n      s = _ref112$strict === void 0 ? !1 : _ref112$strict;\n    const _e$useState7 = e.useState(!Xa(n)),\n      _e$useState8 = _slicedToArray(_e$useState7, 2),\n      i = _e$useState8[1],\n      o = e.useRef(void 0);\n    if (!Xa(n)) {\n      const t = n.renderer,\n        e = _objectWithoutProperties(n, _excluded21);\n      o.current = t, W(e);\n    }\n    return e.useEffect(() => {\n      Xa(n) && n().then(_ref113 => {\n        let t = _ref113.renderer,\n          e = _objectWithoutProperties(_ref113, _excluded22);\n        W(e), o.current = t, i(!0);\n      });\n    }, []), d(x.Provider, {\n      value: {\n        renderer: o.current,\n        strict: s\n      },\n      children: t\n    });\n  }, t.MotionConfig = function (_ref114) {\n    let t = _ref114.children,\n      n = _ref114.isValidProp,\n      s = _objectWithoutProperties(_ref114, _excluded23);\n    n && jt(n), (s = _objectSpread(_objectSpread({}, e.useContext(p)), s)).isStatic = Jt(() => s.isStatic);\n    const i = e.useMemo(() => s, [JSON.stringify(s.transition), s.transformPagePoint, s.reducedMotion]);\n    return d(p.Provider, {\n      value: i,\n      children: t\n    });\n  }, t.MotionConfigContext = p, t.MotionContext = f, t.MotionGlobalConfig = T, t.MotionValue = ni, t.PresenceContext = g, t.Reorder = il, t.SwitchLayoutGroupContext = z, t.VisualElement = _o, t.addPointerEvent = fe, t.addPointerInfo = pe, t.addScaleCorrector = q, t.animate = gr, t.animateValue = Us, t.animateVisualElement = ci, t.animationControls = fl, t.animations = yi, t.anticipate = ds, t.backIn = cs, t.backInOut = hs, t.backOut = us, t.buildTransform = st, t.calcLength = Ci, t.cancelFrame = oe, t.cancelSync = Xr, t.circIn = rs, t.circInOut = ls, t.circOut = as, t.clamp = ct, t.color = bn, t.complex = Rn, t.createBox = Ui, t.createDomMotionComponent = function (t) {\n    return $(ce(t, {\n      forwardMotionProps: !1\n    }, Fa, La));\n  }, t.createMotionComponent = $, t.createScopedAnimate = fr, t.cubicBezier = Qn, t.delay = Bo, t.disableInstantTransitions = function () {\n    He.current = !1;\n  }, t.distance = vi, t.distance2D = xi, t.domAnimation = ol, t.domMax = rl, t.easeIn = ts, t.easeInOut = ns, t.easeOut = es, t.filterProps = Ot, t.frame = ie, t.frameData = re, t.inView = Hr, t.interpolate = Rs, t.invariant = Ze, t.isBrowser = y, t.isDragActive = Te, t.isMotionComponent = Pl, t.isMotionValue = tt, t.isValidMotionProp = Bt, t.m = Oa, t.makeUseVisualState = ee, t.mirrorEasing = is, t.mix = Ms, t.motion = ja, t.motionValue = si, t.optimizedAppearDataAttribute = w, t.pipe = ye, t.progress = fs, t.px = Tt, t.resolveMotionValue = te, t.reverseEasing = os, t.scroll = function (t, e) {\n    const n = Nr(e);\n    return \"function\" == typeof t ? Oo(t, n) : t.attachTimeline(n);\n  }, t.scrollInfo = Ur, t.spring = qn, t.stagger = function () {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .1;\n    let _ref115 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref115$startDelay = _ref115.startDelay,\n      e = _ref115$startDelay === void 0 ? 0 : _ref115$startDelay,\n      _ref115$from = _ref115.from,\n      n = _ref115$from === void 0 ? 0 : _ref115$from,\n      s = _ref115.ease;\n    return (i, o) => {\n      const r = \"number\" == typeof n ? n : function (t, e) {\n          if (\"first\" === t) return 0;\n          {\n            const n = e - 1;\n            return \"last\" === t ? n : n / 2;\n          }\n        }(n, o),\n        a = Math.abs(r - i);\n      let l = t * a;\n      if (s) {\n        const e = o * t;\n        l = ps(s)(l / e) * e;\n      }\n      return e + l;\n    };\n  }, t.startOptimizedAppearAnimation = function (t, e, n, s, i) {\n    if (window.HandoffComplete) return void (window.HandoffAppearAnimations = void 0);\n    const o = t.dataset.framerAppearId;\n    if (!o) return;\n    window.HandoffAppearAnimations = Vl;\n    const r = Sl(o, e);\n    Cl || (Cl = Xs(t, e, [n[0], n[0]], {\n      duration: 1e4,\n      ease: \"linear\"\n    }), bl.set(r, {\n      animation: Cl,\n      startTime: null\n    }), window.HandoffCancelAllAnimations || (window.HandoffCancelAllAnimations = () => {\n      bl.forEach(_ref116 => {\n        let t = _ref116.animation;\n        t.cancel();\n      }), bl.clear(), window.HandoffCancelAllAnimations = void 0;\n    }));\n    const a = () => {\n      Cl.cancel();\n      const o = Xs(t, e, n, s);\n      void 0 === El && (El = performance.now()), o.startTime = El, bl.set(r, {\n        animation: o,\n        startTime: El\n      }), i && i(o);\n    };\n    Cl.ready ? Cl.ready.then(a).catch(se) : a();\n  }, t.steps = ae, t.sync = Yr, t.transform = $r, t.unwrapMotionComponent = function (t) {\n    if (Pl(t)) return t[H];\n  }, t.useAnimate = function () {\n    const t = Jt(() => ({\n        current: null,\n        animations: []\n      })),\n      e = Jt(() => fr(t));\n    return $a(() => {\n      t.animations.forEach(t => t.stop());\n    }), [t, e];\n  }, t.useAnimation = yl, t.useAnimationControls = gl, t.useAnimationFrame = hl, t.useCycle = function () {\n    for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      t[_key4] = arguments[_key4];\n    }\n    const n = e.useRef(0),\n      _e$useState9 = e.useState(t[n.current]),\n      _e$useState10 = _slicedToArray(_e$useState9, 2),\n      s = _e$useState10[0],\n      i = _e$useState10[1];\n    return [s, e.useCallback(e => {\n      n.current = \"number\" != typeof e ? sr(0, t.length, n.current + 1) : e, i(t[n.current]);\n    }, [t.length, ...t])];\n  }, t.useDeprecatedAnimatedState = function (t) {\n    const _e$useState11 = e.useState(t),\n      _e$useState12 = _slicedToArray(_e$useState11, 2),\n      n = _e$useState12[0],\n      s = _e$useState12[1],\n      i = Dl({}, !1),\n      o = Jt(() => new Rl({\n        props: {},\n        visualState: i,\n        presenceContext: null\n      }, {\n        initialState: t\n      }));\n    return e.useEffect(() => (o.mount({}), () => o.unmount()), [o]), e.useEffect(() => {\n      o.update({\n        onUpdate: t => {\n          s(_objectSpread({}, t));\n        }\n      }, null);\n    }, [s, o]), [n, Jt(() => t => ci(o, t))];\n  }, t.useDeprecatedInvertedScale = function (t) {\n    let n = Qa(1),\n      s = Qa(1);\n    const _e$useContext5 = e.useContext(f),\n      i = _e$useContext5.visualElement;\n    return t ? (n = t.scaleX || n, s = t.scaleY || s) : i && (n = i.getValue(\"scaleX\", 1), s = i.getValue(\"scaleY\", 1)), {\n      scaleX: el(n, kl),\n      scaleY: el(s, kl)\n    };\n  }, t.useDomEvent = function (t, n, s, i) {\n    e.useEffect(() => {\n      const e = t.current;\n      if (s && e) return he(e, n, s, i);\n    }, [t, n, s, i]);\n  }, t.useDragControls = function () {\n    return Jt(xl);\n  }, t.useElementScroll = function (t) {\n    return cl({\n      container: t\n    });\n  }, t.useForceUpdate = Ua, t.useInView = function (t) {\n    let _ref117 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      n = _ref117.root,\n      s = _ref117.margin,\n      i = _ref117.amount,\n      _ref117$once = _ref117.once,\n      o = _ref117$once === void 0 ? !1 : _ref117$once;\n    const _e$useState13 = e.useState(!1),\n      _e$useState14 = _slicedToArray(_e$useState13, 2),\n      r = _e$useState14[0],\n      a = _e$useState14[1];\n    return e.useEffect(() => {\n      if (!t.current || o && r) return;\n      const e = {\n        root: n && n.current || void 0,\n        margin: s,\n        amount: i\n      };\n      return Hr(t.current, () => (a(!0), o ? void 0 : () => a(!1)), e);\n    }, [n, t, s, o, i]), r;\n  }, t.useInstantLayoutTransition = wl, t.useInstantTransition = function () {\n    const _Ua3 = Ua(),\n      _Ua4 = _slicedToArray(_Ua3, 2),\n      t = _Ua4[0],\n      n = _Ua4[1],\n      s = wl(),\n      i = e.useRef();\n    return e.useEffect(() => {\n      ie.postRender(() => ie.postRender(() => {\n        n === i.current && (He.current = !1);\n      }));\n    }, [n]), e => {\n      s(() => {\n        He.current = !0, t(), e(), i.current = n + 1;\n      });\n    };\n  }, t.useIsPresent = function () {\n    return null === (t = e.useContext(g)) || t.isPresent;\n    var t;\n  }, t.useIsomorphicLayoutEffect = v, t.useMotionTemplate = function (t) {\n    for (var _len5 = arguments.length, e = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      e[_key5 - 1] = arguments[_key5];\n    }\n    const n = t.length;\n    return tl(e.filter(tt), function () {\n      let s = \"\";\n      for (let i = 0; i < n; i++) {\n        s += t[i];\n        const n = e[i];\n        n && (s += tt(n) ? n.get() : n);\n      }\n      return s;\n    });\n  }, t.useMotionValue = Qa, t.useMotionValueEvent = al, t.usePresence = Va, t.useReducedMotion = ml, t.useReducedMotionConfig = function () {\n    const t = ml(),\n      _e$useContext6 = e.useContext(p),\n      n = _e$useContext6.reducedMotion;\n    return \"never\" !== n && (\"always\" === n || t);\n  }, t.useResetProjection = function () {\n    return e.useCallback(() => {\n      const t = wa.current;\n      t && t.resetTree();\n    }, []);\n  }, t.useScroll = cl, t.useSpring = function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const _e$useContext7 = e.useContext(p),\n      s = _e$useContext7.isStatic,\n      i = e.useRef(null),\n      o = Qa(tt(t) ? t.get() : t),\n      r = () => {\n        i.current && i.current.stop();\n      };\n    return e.useInsertionEffect(() => o.attach((t, e) => {\n      if (s) return e(t);\n      const a = i.current;\n      return a && 0 === a.time && a.sample(re.delta), r(), i.current = Us(_objectSpread(_objectSpread({\n        keyframes: [o.get(), t],\n        velocity: o.getVelocity(),\n        type: \"spring\",\n        restDelta: .001,\n        restSpeed: .01\n      }, n), {}, {\n        onUpdate: e\n      })), o.get();\n    }, r), [JSON.stringify(n)]), v(() => {\n      if (tt(t)) return t.on(\"change\", t => o.set(parseFloat(t)));\n    }, [o]), o;\n  }, t.useTime = function () {\n    const t = Qa(0);\n    return hl(e => t.set(e)), t;\n  }, t.useTransform = el, t.useUnmountEffect = $a, t.useVelocity = function (t) {\n    const e = Qa(t.getVelocity()),\n      n = () => {\n        const s = t.getVelocity();\n        e.set(s), s && ie.update(n);\n      };\n    return al(t, \"change\", () => {\n      ie.update(n, !1, !0);\n    }), e;\n  }, t.useViewportScroll = function () {\n    return cl();\n  }, t.useWillChange = function () {\n    return Jt(() => new dl(\"auto\"));\n  }, t.visualElementStore = jo, t.warning = qe, t.wrap = sr;\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}