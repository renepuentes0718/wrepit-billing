{"ast":null,"code":"'use strict';\n\nconst _excluded = [\"route\", \"totpSecretCode\", \"unverifiedUserAttributes\", \"user\"],\n  _excluded2 = [\"error\"],\n  _excluded3 = [\"name\"],\n  _excluded4 = [\"name\", \"value\"],\n  _excluded5 = [\"defaultValues\", \"mode\"],\n  _excluded6 = [\"challengeName\"],\n  _excluded7 = [\"onError\"],\n  _excluded8 = [\"children\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar React = require('react');\nvar react = require('@xstate/react');\nvar auth = require('aws-amplify/auth');\nvar ui = require('@aws-amplify/ui');\nvar reactHookForm = require('react-hook-form');\nvar storage = require('aws-amplify/storage');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n/**\n * AuthenticatorContext serves static reference to the auth machine service.\n *\n * https://xstate.js.org/docs/recipes/react.html#context-provider\n */\nconst AuthenticatorContext = React__default[\"default\"].createContext(null);\nconst createHubHandler = options => (data, service) => {\n  ui.defaultAuthHubHandler(data, service, options);\n};\nfunction AuthenticatorProvider(_ref) {\n  let children = _ref.children;\n  // `authStatus` is exposed by `useAuthenticator` but should not be derived directly from the\n  // state machine as the machine only updates on `Authenticator` initiated events, which\n  // leads to scenarios where the state machine `authStatus` gets \"stuck\". For exmample,\n  // if a user was to sign in using `Auth.signIn` directly rather than using `Authenticator`\n  const _React__default$defau = React__default[\"default\"].useState('configuring'),\n    _React__default$defau2 = _slicedToArray(_React__default$defau, 2),\n    authStatus = _React__default$defau2[0],\n    setAuthStatus = _React__default$defau2[1];\n  // only run on first render\n  React__default[\"default\"].useEffect(() => {\n    auth.getCurrentUser().then(() => {\n      setAuthStatus('authenticated');\n    }).catch(() => {\n      setAuthStatus('unauthenticated');\n    });\n  }, []);\n  /**\n   * Based on use cases, developer might already have added another Provider\n   * outside Authenticator. In that case, we sync the two providers by just\n   * passing the parent value.\n   *\n   * TODO(BREAKING): enforce only one provider in App tree\n   */\n  const parentProviderVal = React.useContext(AuthenticatorContext);\n  const service = react.useInterpret(ui.createAuthenticatorMachine);\n  const value = React.useMemo(() => !parentProviderVal ? {\n    authStatus,\n    service\n  } : parentProviderVal, [authStatus, parentProviderVal, service]);\n  const activeService = value.service;\n  React.useEffect(() => {\n    const onSignIn = () => {\n      setAuthStatus('authenticated');\n    };\n    const onSignOut = () => {\n      setAuthStatus('unauthenticated');\n    };\n    const unsubscribe = ui.listenToAuthHub(activeService, createHubHandler({\n      onSignIn,\n      onSignOut\n    }));\n    return unsubscribe;\n  }, [activeService]);\n  return React__default[\"default\"].createElement(AuthenticatorContext.Provider, {\n    value: value\n  }, children);\n}\nconst USE_AUTHENTICATOR_ERROR = '`useAuthenticator` must be used inside an `Authenticator.Provider`.';\nconst COMPONENT_ROUTE_KEYS = ['confirmResetPassword', 'confirmSignIn', 'confirmSignUp', 'confirmVerifyUser', 'forceNewPassword', 'forgotPassword', 'setupTotp', 'signIn', 'signUp', 'verifyUser'];\nconst COMPONENT_ROUTE_NAMES = ['ConfirmResetPassword', 'ConfirmSignIn', 'ConfirmSignUp', 'ConfirmVerifyUser', 'ForceNewPassword', 'ForgotPassword', 'SetupTotp', 'SignIn', 'SignUp', 'VerifyUser'];\nconst isComponentRouteKey = route => COMPONENT_ROUTE_KEYS.some(componentRoute => componentRoute === route);\nfunction resolveAuthenticatorComponents(defaults, overrides) {\n  if (!overrides) {\n    return defaults;\n  }\n  return COMPONENT_ROUTE_NAMES.reduce((components, route) => {\n    const Default = defaults[route];\n    const Override = overrides[route];\n    if (typeof Override !== 'function') {\n      return _objectSpread(_objectSpread({}, components), {}, {\n        [route]: Default\n      });\n    }\n    const Footer = Default.Footer,\n      FormFields = Default.FormFields,\n      Header = Default.Header;\n    // cast to allow assigning of component slots\n    const Component = Override;\n    Component.Footer = Footer;\n    Component.FormFields = FormFields;\n    Component.Header = Header;\n    return _objectSpread(_objectSpread({}, components), {}, {\n      [route]: Component\n    });\n  }, {});\n}\nconst defaultComparator = () => false;\n/**\n * Does an ordering and shallow comparison of each array value,\n * plus a value equality check for empty objects and arrays.\n */\nfunction areSelectorDepsEqual(currentDeps, nextDeps) {\n  if (currentDeps.length !== nextDeps.length) {\n    return false;\n  }\n  return currentDeps.every((currentDep, index) => {\n    const nextDep = nextDeps[index];\n    if (ui.areEmptyArrays(currentDep, nextDep) || ui.areEmptyObjects(currentDep, nextDep)) {\n      return true;\n    }\n    return currentDep === nextDep;\n  });\n}\nconst getComparator = selector => (currentFacade, nextFacade) => {\n  const currentSelectorDeps = selector(currentFacade);\n  const nextSelectorDeps = selector(nextFacade);\n  // Shallow compare the array values\n  return areSelectorDepsEqual(currentSelectorDeps, nextSelectorDeps);\n};\nconst getQRFields = state => _objectSpread({}, ui.getActorContext(state)?.formFields?.setupTotp?.QR);\nconst flattenFormFields = fields => fields.flatMap(_ref2 => {\n  let _ref3 = _slicedToArray(_ref2, 2),\n    name = _ref3[0],\n    options = _ref3[1];\n  return _objectSpread({\n    name\n  }, options);\n});\nconst convertContactMethodsToFields = unverifiedUserAttributes => {\n  return unverifiedUserAttributes && Object.entries(unverifiedUserAttributes).map(_ref4 => {\n    let _ref5 = _slicedToArray(_ref4, 2),\n      name = _ref5[0],\n      value = _ref5[1];\n    const valueIsString = ui.isString(value);\n    if (!valueIsString || !name) {\n      return {};\n    }\n    return {\n      name,\n      label: value,\n      type: 'radio',\n      value\n    };\n  });\n};\n/**\n * Retrieves default and custom (RWA only, to be updated) form field values from state machine\n * for subcomponent routes that render fields\n */\nconst getMachineFields = (route, state, unverifiedUserAttributes) => {\n  if (isComponentRouteKey(route)) {\n    return route === 'verifyUser' ? convertContactMethodsToFields(unverifiedUserAttributes) : flattenFormFields(ui.getSortedFormFields(route, state));\n  }\n  return [];\n};\n\n/**\n * [ðŸ“– Docs](https://ui.docs.amplify.aws/react/connected-components/authenticator/headless#useauthenticator-hook)\n */\nfunction useAuthenticator(selector) {\n  const context = React__default[\"default\"].useContext(AuthenticatorContext);\n  if (!context) {\n    throw new Error(USE_AUTHENTICATOR_ERROR);\n  }\n  const service = context.service;\n  const send = service.send;\n  const xstateSelector = React.useCallback(state => _objectSpread({}, ui.getServiceFacade({\n    send,\n    state\n  })), [send]);\n  const comparator = selector ? getComparator(selector) : defaultComparator;\n  // the purpose of `context.authStatus`is to intentionally override `facade.authStatus`. `facade.authStatus` does\n  // not update on external sign in events (for example when a user is not using the `Authenticator`).\n  const authStatus = context.authStatus;\n  const facade = react.useSelector(service, xstateSelector, comparator);\n  const route = facade.route,\n    totpSecretCode = facade.totpSecretCode,\n    unverifiedUserAttributes = facade.unverifiedUserAttributes,\n    user = facade.user,\n    rest = _objectWithoutProperties(facade, _excluded);\n  // do not memoize output. `service.getSnapshot` reference remains stable preventing\n  // `fields` from updating with current form state on value changes\n  const serviceSnapshot = service.getSnapshot();\n  // legacy `QRFields` values only used for SetupTotp page to retrieve issuer information, will be removed in future\n  const QRFields = route === 'setupTotp' ? getQRFields(serviceSnapshot) : null;\n  // legacy `formFields` values required until form state is removed from state machine\n  const fields = getMachineFields(route, serviceSnapshot, unverifiedUserAttributes);\n  return _objectSpread(_objectSpread({}, rest), {}, {\n    authStatus,\n    route,\n    totpSecretCode,\n    unverifiedUserAttributes,\n    user,\n    /** @deprecated For internal use only */\n    fields,\n    QRFields\n  });\n}\nconst DEFAULT_ERROR_MESSAGE$1 = '`useForm` must be called inside a `FormProvider`';\n/**\n * Utility hook corresponding to `FormProvider`, must be used within a `FormProvider`\n *\n * @internal Extend for public export. `useForm` and `UseForm` are an abstraction layer\n * on top of `useFormContext` and `UseFormReturn`, imported from `react-hook-form`\n *\n * @param options optional parameters\n * @returns `Form` utilities\n */\nfunction useForm() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const formContext = reactHookForm.useFormContext();\n  const errorMessage = options.errorMessage,\n    _onSubmit = options.onSubmit;\n  if (!formContext) {\n    throw new Error(errorMessage ?? DEFAULT_ERROR_MESSAGE$1);\n  }\n  const formState = formContext.formState,\n    _getFieldState = formContext.getFieldState,\n    getValues = formContext.getValues,\n    handleSubmit = formContext.handleSubmit,\n    register = formContext.register,\n    reset = formContext.reset,\n    setValue = formContext.setValue;\n  // Do not memoize, `formState` updates on all events\n  const getFieldState = name => {\n    const _getFieldState2 = _getFieldState(name, formState),\n      error = _getFieldState2.error,\n      fieldState = _objectWithoutProperties(_getFieldState2, _excluded2);\n    const _ref6 = error ?? {},\n      errorMessage = _ref6.message;\n    return _objectSpread(_objectSpread({}, fieldState), {}, {\n      errorMessage,\n      hasError: !!errorMessage\n    });\n  };\n  // memoize `registerField` and `setFormValue` together,\n  // `register` and `setValue` maintain stable references\n  const _React__default$defau3 = React__default[\"default\"].useMemo(() => {\n      return {\n        registerField: _ref7 => {\n          let name = _ref7.name,\n            options = _objectWithoutProperties(_ref7, _excluded3);\n          return register(name, options);\n        },\n        setFormValue: _ref8 => {\n          let name = _ref8.name,\n            value = _ref8.value,\n            options = _objectWithoutProperties(_ref8, _excluded4);\n          return setValue(name, value, options);\n        }\n      };\n    }, [register, setValue]),\n    registerField = _React__default$defau3.registerField,\n    setFormValue = _React__default$defau3.setFormValue;\n  const onSubmit = React__default[\"default\"].useCallback(event => {\n    const handler = _onSubmit ? handleSubmit(_onSubmit) : ui.noop;\n    handler(event);\n  }, [_onSubmit, handleSubmit]);\n  return {\n    getFieldState,\n    getValues,\n    isValid: formState.isValid,\n    onSubmit,\n    registerField,\n    reset,\n    setFormValue\n  };\n}\nconst DEFAULT_ERROR_MESSAGE = '`useField` must be used within a `FormProvider`';\n/**\n * `Field` integration hook for usage with React `Field` components.\n *\n * @param params Requires `name`, all additional params optional\n * @returns `Form` aware `Field` event handlers and state values\n */\nfunction useField(params) {\n  const _useForm = useForm({\n      errorMessage: DEFAULT_ERROR_MESSAGE\n    }),\n    getFieldState = _useForm.getFieldState,\n    registerField = _useForm.registerField;\n  return _objectSpread(_objectSpread({}, registerField(params)), getFieldState(params.name));\n}\nconst DEFAULT_MODE = 'onTouched';\nconst FormProvider = React__default[\"default\"].forwardRef(function FormProvider(_ref9, ref) {\n  let children = _ref9.children,\n    defaultValues = _ref9.defaultValues,\n    _ref9$mode = _ref9.mode,\n    mode = _ref9$mode === void 0 ? DEFAULT_MODE : _ref9$mode;\n  const formProviderProps = reactHookForm.useForm({\n    defaultValues,\n    mode\n  });\n  const getValues = formProviderProps.getValues,\n    reset = formProviderProps.reset;\n  React__default[\"default\"].useImperativeHandle(ref, () => ({\n    getValues,\n    reset: () => reset(defaultValues)\n  }), [defaultValues, getValues, reset]);\n  return React__default[\"default\"].createElement(reactHookForm.FormProvider, _objectSpread({}, formProviderProps), children);\n});\n\n/**\n * @param Child `Form` base component wrapped inside `FormProvider`\n * @returns Composed `Form` component exposing `FormContext` values to descendents\n */\nfunction withFormProvider(Child) {\n  return React__default[\"default\"].forwardRef(function Form(_ref10, ref) {\n    let defaultValues = _ref10.defaultValues,\n      mode = _ref10.mode,\n      props = _objectWithoutProperties(_ref10, _excluded5);\n    return React__default[\"default\"].createElement(FormProvider, {\n      defaultValues: defaultValues,\n      mode: mode,\n      ref: ref\n    }, React__default[\"default\"].createElement(Child, _objectSpread({}, props)));\n  });\n}\n\n/**\n * Utility component for rendering nothing.\n */\nfunction RenderNothing(_) {\n  return null;\n}\nconst EVENT_HANDLER_KEY_MAP = {\n  updateBlur: 'handleBlur',\n  updateForm: 'handleChange',\n  submitForm: 'handleSubmit'\n};\nconst COMMON_ROUTE_MACHINE_KEYS = ['error', 'isPending', 'submitForm', 'updateBlur', 'updateForm'];\nconst CONFIRM_RESET_PASSWORD_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'hasValidationErrors', 'resendCode', 'validationErrors'];\nconst CONFIRM_SIGN_IN_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'challengeName', 'toSignIn'];\nconst CONFIRM_SIGN_UP_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'codeDeliveryDetails', 'resendCode'];\nconst CONFIRM_VERIFY_USER_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'skipVerification'];\nconst FORCE_NEW_PASSWORD_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'hasValidationErrors', 'toSignIn', 'validationErrors'];\nconst RESET_PASSWORD_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'toSignIn'];\nconst SIGN_IN_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'socialProviders', 'toFederatedSignIn', 'toForgotPassword', 'toSignUp'];\nconst SIGN_UP_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'hasValidationErrors', 'socialProviders', 'toFederatedSignIn', 'toSignIn', 'validationErrors'];\nconst SETUP_TOTP_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'toSignIn', 'totpSecretCode', 'username'];\nconst VERIFY_USER_MACHINE_KEYS = [...COMMON_ROUTE_MACHINE_KEYS, 'skipVerification'];\nconst MACHINE_PROP_KEYS = {\n  confirmResetPassword: CONFIRM_RESET_PASSWORD_MACHINE_KEYS,\n  confirmSignIn: CONFIRM_SIGN_IN_MACHINE_KEYS,\n  confirmSignUp: CONFIRM_SIGN_UP_MACHINE_KEYS,\n  confirmVerifyUser: CONFIRM_VERIFY_USER_MACHINE_KEYS,\n  forceNewPassword: FORCE_NEW_PASSWORD_MACHINE_KEYS,\n  signIn: SIGN_IN_MACHINE_KEYS,\n  signUp: SIGN_UP_MACHINE_KEYS,\n  forgotPassword: RESET_PASSWORD_MACHINE_KEYS,\n  setupTotp: SETUP_TOTP_MACHINE_KEYS,\n  verifyUser: VERIFY_USER_MACHINE_KEYS\n};\n\n// only select `route` from machine context\nconst routeSelector$1 = _ref11 => {\n  let route = _ref11.route;\n  return [route];\n};\nconst createSelector = selectorKeys => context => {\n  const dependencies = selectorKeys.map(key => context[key]);\n  // route should always be part of deps, so hook knows when route changes.\n  return [...dependencies, context.route];\n};\nconst getRouteMachineSelector = route => isComponentRouteKey(route) ? createSelector(MACHINE_PROP_KEYS[route]) : routeSelector$1;\nconst isFormEventHandlerKey = key => ['updateBlur', 'updateForm', 'submitForm'].includes(key);\nconst convertEventHandlerKey = key => EVENT_HANDLER_KEY_MAP[key];\nconst getConvertedMachineProps = (route, context) => MACHINE_PROP_KEYS[route].reduce((acc, key) => _objectSpread(_objectSpread({}, acc), {}, {\n  [isFormEventHandlerKey(key) ? convertEventHandlerKey(key) : key]: context[key]\n}), {});\nfunction resolveConfirmResetPasswordRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('confirmResetPassword', props))\n  };\n}\nfunction resolveConfirmSignInRoute(Component, props) {\n  const _getConvertedMachineP = getConvertedMachineProps('confirmSignIn', props),\n    challengeName = _getConvertedMachineP.challengeName,\n    machineProps = _objectWithoutProperties(_getConvertedMachineP, _excluded6);\n  return {\n    Component,\n    props: _objectSpread(_objectSpread(_objectSpread({}, Component), machineProps), {}, {\n      challengeName\n    })\n  };\n}\nfunction resolveConfirmSignUpRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('confirmSignUp', props))\n  };\n}\nfunction resolveConfirmVerifyUserRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('confirmVerifyUser', props))\n  };\n}\nfunction resolveForceNewPasswordRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('forceNewPassword', props))\n  };\n}\nfunction resolveForgotPasswordRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('forgotPassword', props))\n  };\n}\nfunction resolveSetupTotpRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('setupTotp', props))\n  };\n}\nfunction resolveSignInRoute(Component, props) {\n  // default `hideSignUp` to false\n  const hideSignUp = false;\n  return {\n    Component,\n    props: _objectSpread(_objectSpread(_objectSpread({}, Component), getConvertedMachineProps('signIn', props)), {}, {\n      hideSignUp\n    })\n  };\n}\nfunction resolveSignUpRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('signUp', props))\n  };\n}\nfunction resolveVerifyUserRoute(Component, props) {\n  return {\n    Component,\n    props: _objectSpread(_objectSpread({}, Component), getConvertedMachineProps('verifyUser', props))\n  };\n}\nfunction resolveDefault() {\n  return {\n    Component: RenderNothing,\n    props: {}\n  };\n}\nfunction useAuthenticatorRoute(_ref12) {\n  let components = _ref12.components;\n  const _useAuthenticator = useAuthenticator(routeSelector$1),\n    route = _useAuthenticator.route;\n  const routeMachineSelector = React.useMemo(() => getRouteMachineSelector(route), [route]);\n  // `useAuthenticator` exposes both state machine (example: `toSignIn`) and non-state machine\n  // props (example: `getTotpSecretCode`). `routeSelector` specifies which state machine props\n  // should be returned for a specific route.\n  // Only state machine props specified by the current `routeSelector` will have their current value\n  // returned by `useAuthenticator`, non-machine props returned will always be the current value\n  const routeSelectorProps = useAuthenticator(routeMachineSelector);\n  const ConfirmResetPassword = components.ConfirmResetPassword,\n    ConfirmSignIn = components.ConfirmSignIn,\n    ConfirmSignUp = components.ConfirmSignUp,\n    ConfirmVerifyUser = components.ConfirmVerifyUser,\n    ForceNewPassword = components.ForceNewPassword,\n    ForgotPassword = components.ForgotPassword,\n    SetupTotp = components.SetupTotp,\n    SignIn = components.SignIn,\n    SignUp = components.SignUp,\n    VerifyUser = components.VerifyUser;\n  switch (route) {\n    case 'confirmResetPassword':\n      {\n        return resolveConfirmResetPasswordRoute(ConfirmResetPassword, routeSelectorProps);\n      }\n    case 'confirmSignIn':\n      {\n        return resolveConfirmSignInRoute(ConfirmSignIn, routeSelectorProps);\n      }\n    case 'confirmSignUp':\n      {\n        return resolveConfirmSignUpRoute(ConfirmSignUp, routeSelectorProps);\n      }\n    case 'confirmVerifyUser':\n      {\n        return resolveConfirmVerifyUserRoute(ConfirmVerifyUser, routeSelectorProps);\n      }\n    case 'forceNewPassword':\n      {\n        return resolveForceNewPasswordRoute(ForceNewPassword, routeSelectorProps);\n      }\n    case 'forgotPassword':\n      {\n        return resolveForgotPasswordRoute(ForgotPassword, routeSelectorProps);\n      }\n    case 'setupTotp':\n      {\n        return resolveSetupTotpRoute(SetupTotp, routeSelectorProps);\n      }\n    case 'signIn':\n      {\n        return resolveSignInRoute(SignIn, routeSelectorProps);\n      }\n    case 'signUp':\n      {\n        return resolveSignUpRoute(SignUp, routeSelectorProps);\n      }\n    case 'verifyUser':\n      {\n        return resolveVerifyUserRoute(VerifyUser, routeSelectorProps);\n      }\n    default:\n      {\n        return resolveDefault();\n      }\n  }\n}\n\n// only select `route` from machine context\nconst routeSelector = _ref13 => {\n  let route = _ref13.route;\n  return [route];\n};\nfunction useAuthenticatorInitMachine(data) {\n  const _useAuthenticator2 = useAuthenticator(routeSelector),\n    route = _useAuthenticator2.route,\n    initializeMachine = _useAuthenticator2.initializeMachine;\n  const hasInitialized = React__default[\"default\"].useRef(false);\n  React__default[\"default\"].useEffect(() => {\n    if (!hasInitialized.current && route === 'setup') {\n      initializeMachine(data);\n      hasInitialized.current = true;\n    }\n  }, [initializeMachine, route, data]);\n}\n\n/**\n * Logs a deprecation warning message.\n *\n * @important Please use the React/React Native specific platform implementations.\n * This version of the hook is a base implementation that the others extend from due\n * to env differences between running in RN or the browser\n */\nconst useDeprecationWarning = _ref14 => {\n  let shouldWarn = _ref14.shouldWarn,\n    message = _ref14.message;\n  React__namespace.useEffect(() => {\n    if (shouldWarn) {\n      // eslint-disable-next-line no-console\n      console.warn(message);\n    }\n  }, [shouldWarn, message]);\n};\nconst INIT_STATE = {\n  url: undefined,\n  expiresAt: undefined,\n  isLoading: true\n};\nfunction useGetUrl(input) {\n  const _React__namespace$use = React__namespace.useState(() => INIT_STATE),\n    _React__namespace$use2 = _slicedToArray(_React__namespace$use, 2),\n    result = _React__namespace$use2[0],\n    setResult = _React__namespace$use2[1];\n  React__namespace.useEffect(() => {\n    const onError = input.onError,\n      getUrlInput = _objectWithoutProperties(input, _excluded7);\n    let ignore = false;\n    storage.getUrl(getUrlInput).then(response => {\n      if (ignore) {\n        return;\n      }\n      setResult(_objectSpread(_objectSpread({}, response), {}, {\n        isLoading: false\n      }));\n    }).catch(error => {\n      if (ignore) {\n        return;\n      }\n      if (ui.isFunction(onError)) {\n        onError(error);\n      }\n      setResult(_objectSpread(_objectSpread({}, INIT_STATE), {}, {\n        isLoading: false\n      }));\n    });\n    return () => {\n      ignore = true;\n    };\n  }, [input]);\n  return result;\n}\nfunction usePreviousValue(value) {\n  const previous = React.useRef();\n  // update ref post render\n  React.useEffect(() => {\n    previous.current = value;\n  }, [value]);\n  // return previous ref\n  return previous.current;\n}\n\n/**\n * @param value `value` to track for updates\n * @param ignoreFirstRender whether to ignore initial render. defaults to `false`\n * @returns a boolean representing whether the tracked `value` has updated between renders\n *\n * Returns `false`:\n * - on initial render when ignoring first render\n * - current and previous `value` are equal\n *\n * Returns `true`:\n * - on initial render when not ignoring first render (default behavior)\n * - current and previous `value` are not equal\n */\nfunction useHasValueUpdated(value) {\n  let ignoreFirstRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const previous = usePreviousValue(value);\n  const shouldIgnoreChange = ui.isUndefined(previous) && ignoreFirstRender;\n  if (shouldIgnoreChange) {\n    return false;\n  }\n  return previous !== value;\n}\nfunction useSetUserAgent(_ref15) {\n  let componentName = _ref15.componentName,\n    packageName = _ref15.packageName,\n    version = _ref15.version;\n  React.useEffect(() => {\n    const clearUserAgent = ui.setUserAgent({\n      componentName,\n      packageName,\n      version\n    });\n    return clearUserAgent;\n  }, [componentName, packageName, version]);\n}\nfunction useTimeout(_ref16) {\n  let callback = _ref16.callback,\n    delay = _ref16.delay;\n  const storedCallback = React__default[\"default\"].useRef(callback);\n  React__default[\"default\"].useLayoutEffect(() => {\n    storedCallback.current = callback;\n  }, [callback]);\n  React__default[\"default\"].useEffect(() => {\n    if (!ui.isTypedFunction(storedCallback.current) || !delay) {\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      storedCallback.current?.();\n    }, delay);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [delay]);\n}\nconst INVALID_OPTIONS_MESSAGE = 'an `errorMessage` or a `defaultValue` must be provided in `options`';\n/**\n * Uses `ContextType`/`Name` generics and `options` to create:\n * - `${Name}Context`: React Context of type `ContextType`\n * - `Provider${Name}`: React Context `Provider` component exposing the `ContextType`\n *   as optional props\n * - `use${Name}`: Utility Hook exposing the values of `ContextType`. Allows\n *   params with `errorMessage` for granular error messaging\n *\n * @template ContextType Type definition of the Context.\n * > For most use cases the keys of `ContextType` should not be optional in\n * preference of explicit `undefined` to avoid optional types on the\n * Utility Hook return\n *\n * @param options Context utility options. Requires a `contextName`, and\n * either a `defaultValue` of `ContextType` **or** an `errorMessage`\n * allowing for differing behaviors of the Utility Hook when used outside a\n * parent `Provider`:\n *\n * - `defaultValue`: Ensures the Utility Hook returns a default value for\n *   scenarios **where the missing context values should not impact usage**\n * - `errorMessage`: Ensures the Utility Hook throws an error for\n *   scenarios **where the missing context values should prevent** usage\n *\n * @returns `Context`, `Provider` Component and `useContext` Utility Hook\n *\n * @usage\n * ```ts\n * interface StuffContextType {\n *   things: number;\n * }\n *\n * // with `defaultValue`\n * const defaultValue: StuffContextType = { things: 7 };\n *\n * const { StuffProvider, useStuff } = createContextUtilities({\n *   contextName: 'Stuff',\n *   defaultValue,\n * });\n *\n * // with `errorMessage`\n * const { StuffProvider, useStuff } = createContextUtilities<StuffContextType>({\n *   contextName: 'Stuff',\n *   errorMessage: '`useStuff` must be used in a `StuffProvider`'\n * });\n * ```\n */\nfunction createContextUtilities(options) {\n  const _ref17 = options ?? {},\n    contextName = _ref17.contextName,\n    defaultValue = _ref17.defaultValue,\n    errorMessage = _ref17.errorMessage;\n  if (ui.isUndefined(defaultValue) && !ui.isString(errorMessage)) {\n    throw new Error(INVALID_OPTIONS_MESSAGE);\n  }\n  const Context = React__default[\"default\"].createContext(defaultValue);\n  function Provider(props) {\n    const children = props.children,\n      context = _objectWithoutProperties(props, _excluded8);\n    const value = React__default[\"default\"].useMemo(() => context,\n    // Unpack `context` for the dep array; using `[context]` results in\n    // evaluation on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    Object.values(context));\n    return React__default[\"default\"].createElement(Context.Provider, {\n      value: value\n    }, children);\n  }\n  Provider.displayName = `${contextName}Provider`;\n  return {\n    [`use${contextName}`]: function (params) {\n      const context = React__default[\"default\"].useContext(Context);\n      if (ui.isUndefined(context)) {\n        throw new Error(params?.errorMessage ?? errorMessage);\n      }\n      return context;\n    },\n    [`${contextName}Provider`]: Provider,\n    [`${contextName}Context`]: Context\n  };\n}\nexports.AuthenticatorProvider = AuthenticatorProvider;\nexports.FormProvider = FormProvider;\nexports.RenderNothing = RenderNothing;\nexports.createContextUtilities = createContextUtilities;\nexports.isAuthenticatorComponentRouteKey = isComponentRouteKey;\nexports.resolveAuthenticatorComponents = resolveAuthenticatorComponents;\nexports.useAuthenticator = useAuthenticator;\nexports.useAuthenticatorInitMachine = useAuthenticatorInitMachine;\nexports.useAuthenticatorRoute = useAuthenticatorRoute;\nexports.useDeprecationWarning = useDeprecationWarning;\nexports.useField = useField;\nexports.useForm = useForm;\nexports.useGetUrl = useGetUrl;\nexports.useHasValueUpdated = useHasValueUpdated;\nexports.usePreviousValue = usePreviousValue;\nexports.useSetUserAgent = useSetUserAgent;\nexports.useTimeout = useTimeout;\nexports.withFormProvider = withFormProvider;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}