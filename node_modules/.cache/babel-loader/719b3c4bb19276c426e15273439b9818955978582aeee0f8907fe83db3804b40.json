{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { getSuspenseCache, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nexport function useBackgroundQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return wrapHook(\"useBackgroundQuery\", _useBackgroundQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\nfunction _useBackgroundQuery(query, options) {\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n    variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n    queryKey = _a === void 0 ? [] : _a;\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  var didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current || (didFetchResult.current = fetchPolicy !== \"standby\");\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n  var _b = React.useState(wrapQueryRef(queryRef)),\n    wrappedQueryRef = _b[0],\n    setWrappedQueryRef = _b[1];\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    var promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(function () {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    var id = setTimeout(function () {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n    return function () {\n      return clearTimeout(id);\n    };\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  React.useEffect(function () {\n    return queryRef.softRetain();\n  }, [queryRef]);\n  return [didFetchResult.current ? wrappedQueryRef : void 0, {\n    fetchMore: fetchMore,\n    refetch: refetch\n  }];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}