{"ast":null,"code":"const _excluded = [\"rowSpan\", \"columnSpan\", \"row\", \"column\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport * as React from 'react';\nimport { isDesignToken } from '@aws-amplify/ui';\nimport { ComponentPropsToStylePropsMap } from '../types/style.mjs';\nimport { getValueAtCurrentBreakpoint } from './responsive/utils.mjs';\nimport { useBreakpoint } from './responsive/useBreakpoint.mjs';\nimport { useTheme } from '../../hooks/useTheme.mjs';\nimport { getStyleValue } from './getStyleValue.mjs';\nimport { isNullOrEmptyString, isEmptyString, getCSSVariableIfValueIsThemeKey } from './utils.mjs';\nconst isSpanPrimitiveValue = spanValue => {\n  return spanValue === 'auto' || typeof spanValue === 'number' && !isNaN(spanValue) || typeof spanValue === 'string' && !isNaN(parseFloat(spanValue));\n};\nconst getGridSpan = spanValue => {\n  return spanValue === 'auto' ? 'auto' : `span ${spanValue}`;\n};\nconst convertGridSpan = spanValue => {\n  // PropertyType\n  if (isSpanPrimitiveValue(spanValue)) {\n    return getGridSpan(spanValue);\n  }\n  // PropertyType[]\n  if (Array.isArray(spanValue)) {\n    return spanValue.map(value => getGridSpan(value));\n  }\n  // ResponsiveObject<PropertyType>\n  if (typeof spanValue === 'object' && spanValue != null) {\n    return Object.entries(spanValue).reduce((acc, _ref) => {\n      let _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      return _objectSpread(_objectSpread({}, acc), {}, {\n        [key]: getGridSpan(value)\n      });\n    }, {});\n  }\n  return null;\n};\n/**\n * Transforms style props to another target prop\n * where the original is a simpler API than the target.\n * This function will remove the original prop and\n * replace target prop values with calculated\n * E.g. rowSpan => row, columnSpan => column\n */\nconst useTransformStyleProps = props => {\n  const rowSpan = props.rowSpan,\n    columnSpan = props.columnSpan,\n    row = props.row,\n    column = props.column,\n    rest = _objectWithoutProperties(props, _excluded);\n  const _React$useMemo = React.useMemo(() => {\n      return {\n        rowFromSpanValue: convertGridSpan(rowSpan),\n        columnFromSpanValue: convertGridSpan(columnSpan)\n      };\n    }, [rowSpan, columnSpan]),\n    rowFromSpanValue = _React$useMemo.rowFromSpanValue,\n    columnFromSpanValue = _React$useMemo.columnFromSpanValue;\n  return _objectSpread({\n    row: !isNullOrEmptyString(row) ? row : rowFromSpanValue,\n    column: !isNullOrEmptyString(column) ? column : columnFromSpanValue\n  }, rest);\n};\nconst isComponentStyleProp = key => {\n  return key in ComponentPropsToStylePropsMap;\n};\n/**\n * Convert style props to CSS variables for React style prop\n * Note: Will filter out undefined, null, and empty string prop values\n */\nconst convertStylePropsToStyleObj = _ref3 => {\n  let _ref3$props = _ref3.props,\n    props = _ref3$props === void 0 ? {} : _ref3$props,\n    _ref3$style = _ref3.style,\n    style = _ref3$style === void 0 ? {} : _ref3$style,\n    breakpoint = _ref3.breakpoint,\n    breakpoints = _ref3.breakpoints,\n    tokens = _ref3.tokens;\n  const nonStyleProps = {};\n  Object.keys(props).filter(propKey => props[propKey] !== null).forEach(propKey => {\n    if (isComponentStyleProp(propKey)) {\n      const values = props[propKey];\n      if (!values || isEmptyString(values)) return;\n      const reactStyleProp = ComponentPropsToStylePropsMap[propKey];\n      // short circuit the style prop here if it is a string or design token\n      // so we don't have to call getValueAtCurrentBreakpoint every time\n      let value = '';\n      if (isDesignToken(values)) {\n        value = values.toString();\n      } else if (typeof values === 'string') {\n        value = getCSSVariableIfValueIsThemeKey(propKey, values, tokens);\n      } else if (typeof values === 'number') {\n        value = values;\n      } else if (typeof values === 'object') {\n        // here values should be a responsive array or object\n        value = getStyleValue({\n          propKey,\n          tokens,\n          value: getValueAtCurrentBreakpoint({\n            values,\n            breakpoint,\n            breakpoints\n          })\n        });\n      }\n      style = _objectSpread(_objectSpread({}, style), {}, {\n        [reactStyleProp]: value\n      });\n    } else if (typeof props[propKey] !== 'undefined') {\n      nonStyleProps[propKey] = props[propKey];\n    }\n  });\n  return {\n    propStyles: style,\n    nonStyleProps\n  };\n};\nconst useStyles = (props, style) => {\n  const _useTheme = useTheme(),\n    _useTheme$breakpoints = _useTheme.breakpoints,\n    breakpoints = _useTheme$breakpoints.values,\n    defaultBreakpoint = _useTheme$breakpoints.defaultBreakpoint,\n    tokens = _useTheme.tokens;\n  const breakpoint = useBreakpoint({\n    breakpoints,\n    defaultBreakpoint\n  });\n  const propStyles = useTransformStyleProps(props);\n  return React.useMemo(() => convertStylePropsToStyleObj({\n    props: propStyles,\n    style,\n    breakpoint,\n    breakpoints,\n    tokens\n  }), [propStyles, style, breakpoints, breakpoint, tokens]);\n};\nexport { convertGridSpan, convertStylePropsToStyleObj, getGridSpan, isSpanPrimitiveValue, useStyles, useTransformStyleProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}