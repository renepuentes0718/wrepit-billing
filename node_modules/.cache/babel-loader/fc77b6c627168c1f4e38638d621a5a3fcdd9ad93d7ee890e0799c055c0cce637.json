{"ast":null,"code":"import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  startObserver() {\n    this.unmount();\n    const _this$node$getProps = this.node.getProps(),\n      _this$node$getProps$v = _this$node$getProps.viewport,\n      viewport = _this$node$getProps$v === void 0 ? {} : _this$node$getProps$v;\n    const root = viewport.root,\n      rootMargin = viewport.margin,\n      _viewport$amount = viewport.amount,\n      amount = _viewport$amount === void 0 ? \"some\" : _viewport$amount,\n      once = viewport.once;\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = entry => {\n      const isIntersecting = entry.isIntersecting;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      const _this$node$getProps2 = this.node.getProps(),\n        onViewportEnter = _this$node$getProps2.onViewportEnter,\n        onViewportLeave = _this$node$getProps2.onViewportLeave;\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const _this$node = this.node,\n      props = _this$node.props,\n      prevProps = _this$node.prevProps;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {}\n}\nfunction hasViewportOptionChanged(_ref) {\n  let _ref$viewport = _ref.viewport,\n    viewport = _ref$viewport === void 0 ? {} : _ref$viewport;\n  let _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref2$viewport = _ref2.viewport,\n    prevViewport = _ref2$viewport === void 0 ? {} : _ref2$viewport;\n  return name => viewport[name] !== prevViewport[name];\n}\nexport { InViewFeature };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}